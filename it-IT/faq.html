<!DOCTYPE html>
<!-- Page last generated 2018-12-06 19:24:32 +0000 -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Domande Frequenti &middot; Linguaggio di programmazione Rust</title>
    <meta name="keywords" content="Rust, Linguaggio di programmazione Rust, rustlang, rust-lang, Mozilla Rust">
    <meta name="description" content="Un linguaggio di programmazione per sistemi ad altissime prestazioni che previene errori di segmentazione e assicura la sicurezza della memoria.">

    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/style.css">
  </head>

  <body class="container">
    <a href="https://github.com/rust-lang/rust">
      <img class="ribbon" style="display: none" src="/logos/forkme_it_it.svg" alt="Forkami on GitHub" width="298" height="298">
    </a>

    <header>
      <ul class="row menu">
	<li class="col-xs-12 col-md-2">
          <a href="/it-IT/index.html">
            <img class="img-responsive" src="/logos/rust-logo-blk.svg" onerror="this.src='/logos/rust-logo-256x256-blk.png'" height="128" width="128" alt="Rust logo" />
          </a>
	</li>
	<li class="col-xs-12 col-md-10 menu">
	  <h2><a href="/it-IT/documentation.html">Documentazione</a></h2>
	  <h2><a href="/it-IT/install.html">Installazione</a></h2>
	  <h2><a href="/it-IT/community.html">Comunità</a></h2>
	  <h2><a href="/it-IT/contribute.html">Contribuisci</a></h2>
	</li>
      </ul>
    </header>

    <h1 id="domande-frequenti">Domande Frequenti</h1>

<p class="faq-intro">
Questa pagina risponde a domande comuni inerenti il linguaggio di programmazione Rust.
Non rappresenta una guida completa al linguaggio e nemmeno uno strumento per insegnarlo.
Costituisce invece un riferimento per rispondere alle domande più frequenti concernenti le scelte di progettazione su cui Rust si basa.
</p>

<p class="faq-intro">
Se c'è una domanda comune o importante che pensi sia ingiustamente esclusa qui, sentiti libero di <a href="https://github.com/rust-lang/rust-www/blob/master/CONTRIBUTING.md">aiutarci ad aggiungerla</a>.
</p>

<div id="toc">
    <h2>Indice</h2><a href="#toggle-toc"></a>
    <div class="contents">
        <ol id="toc-contents">
            <li><a href="#project">Il progetto Rust</a></li>
            <li><a href="#performance">Prestazione</a></li>
            <li><a href="#syntax">Sintassi</a></li>
            <li><a href="#numerics">Numeri</a></li>
            <li><a href="#strings">Strings</a></li>
            <li><a href="#collections">Collezioni</a></li>
            <li><a href="#ownership">Possesso</a></li>
            <li><a href="#lifetimes">Campo di esistenza</a></li>
            <li><a href="#generics">Generici</a></li>
            <li><a href="#input-output">Input / Output</a></li>
            <li><a href="#error-handling">Gestione Errori</a></li>
            <li><a href="#concurrency">Concorrenza</a></li>
            <li><a href="#macros">Macro</a></li>
            <li><a href="#debugging">Debugging e Strumentazione</a></li>
            <li><a href="#low-level">Basso Livello</a></li>
            <li><a href="#cross-platform">Multipiattaforma</a></li>
            <li><a href="#modules-and-crates">Moduli e Pacchetti</a></li>
            <li><a href="#libraries">Librerie</a></li>
            <li><a href="#design-patterns">Paradigmi di progettazione</a></li>
            <li><a href="#other-languages">Altri Linguaggi</a></li>
            <li><a href="#documentation">Documentazione</a></li>
        </ol>
    </div>
</div>

<h2 id="project">Il progetto Rust</h2>

<h3><a href="#what-is-this-projects-goal" name="what-is-this-projects-goal">
Qual è lo scopo del progetto?
</a></h3>

<p>Progettare e implementare un linguaggio sicuro, concorrente e pratico per la programmazione di sistemi.</p>

<p>Rust nasce perchè altri linguaggi a questo livello di astrazione e efficienza non sono soddisfacenti. In particolare:</p>

<ol>
  <li>Non viene posta la dovuta attenzione alla sicurezza.</li>
  <li>Supportano malamente la concorrenza.</li>
  <li>Vi è una carenza di ergonomia.</li>
  <li>Offrono un controllo limitato delle risorse.</li>
</ol>

<p>Rust esiste come un’alternativa che fornisce sia codice efficiente che un livello confortevole di astrazione, contemporaneamente migliorando tutti questi quattro punti.</p>
<h3><a href="#is-this-project-controlled-by-mozilla" name="is-this-project-controlled-by-mozilla">
Questo progetto è controllato da Mozilla?
</a></h3>

<p>No. Rust ebbe inizio nel 2006 come un progetto hobbystico di Graydon Hoare ed è rimasto così per oltre 3 anni. Mozilla è entrata nel 2009, dopo che il linguaggio si è dimostrato abbastanza maturo per eseguire una serie di test di base automatizzati e dimostrare la valenza dei suoi principi base. Anche se sponsorizzato da Mozilla, Rust è un progetto sviluppato da
una variegata comunità di appassionati da molti paesi del mondo. Il <a href="team.html">Team di Rust</a> è composto sia da membri Mozilla che da esterni e <code class="highlighter-rouge">rust</code> su GitHub ha avuto oltre <a href="https://github.com/rust-lang/rust/">1900 sviluppatori diversi</a> fino a oggi.</p>

<p>Finché concesso <a href="https://github.com/rust-lang/rfcs/blob/master/text/1068-rust-governance.md">dalla politica di gestione del progetto</a>, Rust è amministrato da un team base che imposta
la visione e le priorità del progetto, guidandolo globalmente.
Esistono anche dei sottogruppi per guidare e incoraggiare lo sviluppo in alcune aree di interesse, inclusi il linguaggio, il compilatore, le librerie, gli strumenti, la moderazione delle comunità ufficiali.
La progettazione è guidata da un processo <a href="https://github.com/rust-lang/rfcs">RFC</a>.</p>

<p>Per cambiamenti che non richiedono una RFC, le decisioni sono fatte attraverso richieste di unione sul <a href="https://github.com/rust-lang/rust">repository <code class="highlighter-rouge">rustc</code></a>.</p>

<h3><a href="#what-are-some-non-goals" name="what-are-some-non-goals">
WQuali sono i non-obiettivi di Rust?
</a></h3>

<ol>
  <li>Non impieghiamo nessuna tecnologia particolarmente nuova. Le vecchie tecniche ben consolidate sono ancora le migliori.</li>
  <li>Non ci preme incentivare l’espressività, il minimalismo o l’eleganza sopra ogni altra cosa. Sono obiettivi desiderati ma non fondamentali.</li>
  <li>Non ci interessa coprire tutte le funzionalità del C++ o di qualsiasi altro linguaggio. Rust dovrebbe fornire le funzionalità più richieste.</li>
  <li>Non vogliamo essere immobili al 100%, sicuri al 100%, riflessivi al 100% o troppo dogmatici in qualche modo. Esistono dei compromessi.</li>
  <li>Non chiediamo che Rust funzioni “su ogni piattaforma possibile”. Dovrà eventualmente funzionare senza inutili compromessi sulle piattaforme hardware e software più diffuse.</li>
</ol>

<h3><a href="#how-does-mozilla-use-rust" name="how-does-mozilla-use-rust">
In quali progetti Mozilla utilizza Rust?
</a></h3>

<p>Principalmente in <a href="https://github.com/servo/servo">Servo</a>, un motore di navigazione sperimentale a cui Mozilla sta lavorando. Stanno anche lavorando per <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1135640">integrare componenti Rust</a> in Firefox.</p>

<h3><a href="#what-examples-are-there-of-large-rust-projects" name="what-examples-are-there-of-large-rust-projects">
Che esempi ci sono di grandi progetti in Rust?
</a></h3>

<p>I due più grandi progetti open source sono al momento <a href="https://github.com/servo/servo">Servo</a> e il <a href="https://github.com/rust-lang/rust">compilatore Rust</a> stesso.</p>

<h3><a href="#who-else-is-using-rust" name="who-else-is-using-rust">
Chi altro utilizza Rust?
</a></h3>

<p><a href="friends.html">Un crescente numero di organizzazioni!</a></p>

<!--
### What projects are good examples of idiomatic Rust code?

TODO: Write this answer.
-->

<h3><a href="#how-can-i-try-rust-easily" name="how-can-i-try-rust-easily">
Come posso provare Rust facilmente?
</a></h3>

<p>Il modo più semplice per provare Rust è con la <a href="https://play.rust-lang.org/">playpen</a>, un’applicazione online per scrivere e provare codice Rust. Se invece desideri provare Rust sul tuo computer, <a href="https://www.rust-lang.org/install.html">installalo</a> e prova a seguire la guida al <a href="https://doc.rust-lang.org/stable/book/guessing-game.html">gioco dell’indovino</a> dal libro.</p>

<h3><a href="#how-do-i-get-help-with-rust-issues" name="how-do-i-get-help-with-rust-issues">
Come posso ricevere aiuto con Rust?
</a></h3>

<p>Ci sono diversi modi. Puoi:</p>

<ul>
  <li>Scrivere su <a href="https://users.rust-lang.org/">users.rust-lang.org</a>, il forum ufficiale di Rust</li>
  <li>Chiedere sul <a href="https://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">canale IRC ufficiale di Rust</a> (#rust on irc.mozilla.org)</li>
  <li>Chiedere su <a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a> with the “rust” tag</li>
  <li>Scrivere su <a href="https://www.reddit.com/r/rust">/r/rust</a>, il subreddit non ufficiale di Rust</li>
</ul>

<h3><a href="#why-has-rust-changed-so-much" name="why-has-rust-changed-so-much">
Perché Rust è cambiato così tanto col tempo?
</a></h3>

<p>L’obiettivo iniziale di Rust fu quello di creare un linguaggio di programmazione per sistemi stabile e usabile. Per perseguire questo scopo molte idee sono state esplorate, alcune sono state preservate (campi di esistenza, tratti) mentre altre sono state scartate (il sistema di stati dei tipi, il green threading).
Inoltre durante la transizione verso la versione 1.0, buona parte della libreria standard è stata riscritta per consentire al codice passato di sfruttare al meglio le funzionalità di Rust,
fornendo interfacce di programmazione di qualità, stabili e multipiattaforma.
Ora che Rust è alla versione 1.0, il linguaggio è garantito come “stabile”; e mentre potrebbe continuare a evolversi, il codice funzionante sulla versione attuale dovrebbe continuare a farlo
anche nelle versioni future.</p>

<h3><a href="#how-does-rust-language-versioning-work" name="how-does-rust-language-versioning-work">
Come funziona il numero di versione di Rust?
</a></h3>

<p>Rust segue lo standard <a href="http://semver.org/">SemVer</a>, dove cambiamenti non compatibili con le versioni passate sono ammesse nelle versioni minori se questi cambiamenti
risolvono errori del compilatore, risolvono problemi di sicurezza o cambiano le regole di dichiarazione o inferenza dei tipi in modo da richiedere ulteriore specifica.
Linee guida più dettagliate per cambi di versione minori sono disponibili come RFC approvate sia per il <a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">linguaggio</a> che per la <a href="https://github.com/rust-lang/rfcs/blob/master/text/1105-api-evolution.md">libreria standard</a>.</p>

<p>Rust mantiene tre canali di rilascio: stabile, beta e “nightly”.
I canali stabile e beta sono aggiornati ogni sei settimane, con la nightly che diviene la nuova beta e la beta che diviene la nuova stabile.
Le funzionalità del linguaggio e della libreria standard indicate come non stabili o nascoste dietro a blocchi di implementazione possono essere utilizzati solo
nel canale di rilascio “nightly”. Le nuove funzionalità arrivano come instabili ma sono “liberate” una volta approvate dal team di sviluppo e relativi sottogruppi.
Questo approccio consente di sperimentare e di contemporaneamente fornire una forte garanzia di retrompatibilità del canale stabile.</p>

<p>Per dettagli ulteriori, leggi il post sul blog di Rust <a href="http://blog.rust-lang.org/2014/10/30/Stability.html">“Stability as a Deliverable.”</a></p>

<h3><a href="#can-i-use-unstable-features-on-the-beta-or-stable-channel" name="can-i-use-unstable-features-on-the-beta-or-stable-channel">
Posso utilizzare funzionalità non stabili nei canali stabile e beta?
</a></h3>

<p>No, non puoi. Rust cerca duramente di fornire garanzie sulla stabilità delle funzioni incluse nei canali beta e stabile.
Quando qualcosa è non stabile significa che non è possibile ancora garantire il suo utilizzo e quindi non desideriamo che ci
si basi su queste funzionalità o che queste non vengano modificate.
Questo ci permette di provare i cambiamenti nel canale nightly, preservando le promesse di stabilità.</p>

<p>Molte cose vengono incluse nella stabile e i canali beta e stabile vengono aggiornati ogni sei settimane, con occasionali modifiche dirette anche al canale beta a volte.
Se stai aspettando la disponbilità di una funzionalità e non vuoi usufruire del canale nighly, puoi seguirne lo stato controllando l’etichetta <a href="https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+tracking+label%3AB-unstable"><code class="highlighter-rouge">B-unstable</code></a> sulla bacheca dei problemi.</p>

<h3><a href="#what-are-feature-gates" name="what-are-feature-gates">
Cosa sono i "Feature Gates"?
</a></h3>

<p>I “Feature gates” sono il modo con cui Rust stabilizza funzionalità del compilatore, del linguaggio e della libreria standard.
Una funzione protetta è accessibile esclusivamente nel canale di rilascio “nighly” e solo quando abilitata esplicitamente con la direttiva <code class="highlighter-rouge">#[feature]</code> o con l’argomento a linea di comando <code class="highlighter-rouge">-Z unstable-options</code>.
Quando una funzione è stabilizzata diviene disponbile sul canale di rilascio stabile e non è necessario abilitarla esplicitamente.
A quel punto la funzione è considerata “libera”.
I “Feature gates” consentono agli sviluppatori di provare funzionalità sperimentali mentre sono in fase di implementazione, prima che giungano nel linguaggio stabile.</p>

<h3><a href="#why-a-dual-mit-asl2-license" name="why-a-dual-mit-asl2-license">
Perchè la doppia licenza MIT/ASL2?
</a></h3>

<p>La licenza Apache include importanti protezioni contro le aggressioni legali ma non è compatibile con la GPL versione 2.
Per evitare problemi nell’utilizzo di Rust e GPL2 è stata aggiunta la licenza alternativa MIT.</p>

<h3><a href="#why-a-permissive-license" name="why-a-permissive-license">
Perchè una licenza simil-BSD aperta invece che la MPL o la tri-licenza?
</a></h3>

<p>Questo è parzialmente dovuto alla preferenza dello sviluppatore originario (Graydon) e parzialmente al fatto che i linguaggi tendono ad avere un pubblico più vasto e una serie più variegata di implementazioni e utilizzi di altri prodotti come i browser web. Noi vorremmo appellarci al maggior numero possibile di sviluppatori.</p>

<h2 id="performance">Prestazioni</h2>

<h3><a href="#how-fast-is-rust" name="how-fast-is-rust">
Quanto è performante Rust?
</a></h3>

<p>Molto! Rust è già competitivo con programmi C e C++ ben scritti in una serie di prove (come nel <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/rust.html">Benchmarks Game</a> e <a href="https://github.com/kostya/benchmarks">altri</a>).</p>

<p>Come il C++, il Rust possiede <a href="http://blog.rust-lang.org/2015/05/11/traits.html">astrazioni a costo zero</a> come uno dei suoi principi chiave: nessuna delle astrazioni di Rust impone un rallentamento, in qualsiasi caso.</p>

<p>Dato che Rust utilizza LLVM e cerca di assomigliare a Clang dal punto di vista dell’interazione con LLVM, ogni miglioramento di LLVM è condiviso da Rust.
Nel lungo periodo, la quantità elevata di informazioni presente nel sistema dei tipi di Rust dovrebbe permettere ottimizzazioni difficili o impossibili da implementare in C/C++.</p>

<h3><a href="#is-rust-garbage-collected" name="is-rust-garbage-collected">
Rust è un linguaggio dotato di garbage collection?
</a></h3>

<p>No. Una delle innovazioni fondamentali di Rust è il garantire la sicurezza della memoria (nessun errore di segmentazione) <em>senza</em> richiedere un garbage collector.</p>

<p>Evitando di utilizzare un GC, Rust offre numerosi vantaggi: liberazione prevedibile delle risorse, gestione della memoria meno onerosa e soprattutto nessun sistema aggiuntivo operante durante l’esecuzione.
Tutte queste caratteristiche rendono Rust leggero e facile da implementare in contesti arbitrari e rendono più facile <a href="http://calculist.org/blog/2015/12/23/neon-node-rust/">integrare Rust con i linguaggi in possesso di un GC</a>.</p>

<p>Rust non necessita di un GC grazie al suo sistema di possesso e passaggio ma lo stesso sistema aiuta con una moltitudine di altri problemi, inclusi <a href="http://blog.skylight.io/rust-means-never-having-to-close-a-socket/">la gestione delle risorse in generale</a>
e la <a href="http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">concorrenza</a>.</p>

<p>Per quando il possesso di un valore non fosse abbastanza, i programmi Rust fanno riferimento al tipo puntatore intelligente standard a conteggio dei riferimenti <a href="https://doc.rust-lang.org/std/rc/struct.Rc.html"><code class="highlighter-rouge">Rc</code></a> e alla sua versione sicura in contesti paralleli <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code class="highlighter-rouge">Arc</code></a>, invece di affidarsi a un GC.</p>

<p>Stiamo comunque investigando una garbage collection <em>opzionale</em> come estensione futura.
L’obiettivo è integrarsi fluidamente con ambienti garbage-collected, come quelli offerti dai
motori di Javascript <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey">Spidermonkey</a> e <a href="https://developers.google.com/v8/?hl=en">V8</a>.
Inoltre, qualcuno sta investigando l’implementazione di un garbage collector
<a href="https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/">interamente in Rust</a>
senza supporto del compilatore.</p>

<h3><a href="#why-is-my-program-slow" name="why-is-my-program-slow">
Perché il mio programma è lento?
</a></h3>

<p>Il compilatore di Rust non compila con le ottimizzazioni se non esplicitamente istruito <a href="https://users.rust-lang.org/t/why-does-cargo-build-not-optimise-by-default/4150/3">considerato che le ottimizzazioni rallentano la compilazione e sono scosigliate durante lo sviluppo</a>.</p>

<p>Se compili con <code class="highlighter-rouge">cargo</code> usa il parametro <code class="highlighter-rouge">--release</code>.
Se compili direttamente con <code class="highlighter-rouge">rustc</code>, usa il parametro <code class="highlighter-rouge">-O</code>.
Ciascuno di questi abiliterà le ottimizzazioni.</p>

<h3><a href="#why-is-rustc-slow" name="why-is-rustc-slow">
Rust compila lentamente. Perchè?
</a></h3>

<p>Principalmente per la traduzione del codice e le ottimizzazioni.
Rust fornisce delle astrazioni ad alto livello che vengono compilate in un codice macchina efficiente e queste trasformazioni richiedono molto tempo per essere effettuate, specialmente se in combinazione con le ottimizzazioni.</p>

<p>Ma il tempo di compilazione di Rust non è male come sembra e c’è da essere fiduciosi in un suo miglioramento futuro.
Comparando progetti di dimensioni simili tra il C++ e Rust il tempo di compilazione è generalmente comparabile.
La percezione di lentezza è largamente dovuta alle differenze tra il <em>modello di compilazione</em> del C++ da quello di Rust, l’unità base del C++ è il file mentre in Rust è l’intero pacchetto, composto da molti file.
Di conseguenza durante lo sviluppo la modifica di un file causa molta meno ricompilazione che in Rust.
In questo momento è in corso uno sforzo per implementare una ristrutturazione del compilatore che permetta di effettuare la
<a href="https://github.com/rust-lang/rfcs/blob/master/text/1298-incremental-compilation.md">compilazione incrementale</a>, che consentirà a Rust di implementare un modello più rapido e simile al C++.</p>

<p>Oltre al modello di compilazione, ci sono molti altri aspetti dell’implementazione di Rust e il suo compilatore che ne impattano le prestazioni in fase di compilazione.</p>

<p>Inizialmente, Rust has un sistema di tipi moderatamente complesso e deve spendere un discreto quantitativo di tempo durante la compilazione a verificarne limitazioni e utilizzi, rendendo Rust sicuro durante la sua esecuzione.</p>

<p>Secondariamente, il compilatore di Rust soffre di un debito tecnico di lunga data e risaputamente genera una rappresentazione intermedia per LLVM di bassa qualità a cui LLVM deve porre rimedio.
Si spera che i futuri passaggi di trasformazione e ottimizzazione <a href="https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md">basati su MIR</a> riducano la quantità di lavoro che Rust impone a LLVM.</p>

<p>Terziariamente, l’utilizzo da parte di Rust di LLVM per la generazione del codice macchina è una spada a doppio taglio: se da un lato questo permette a Rust di avere prestazioni degne di nota,
LLVM è un insieme di strumenti non focalizzato alla velocità di compilazione, specialmente con input di bassa qualità.</p>

<p>Inoltre, mentre la strategia preferita da Rust per monomorfizzare i generici (simil C++) produca codice performante, domanda di generare molto più codice rispetto ad altre strategie di implementazione.
I programmatori Rust possono utilizzare i tratti per rimuovere questo codice extra e utilizzando un dispacciamento dinamico.</p>

<h3><a href="#why-are-rusts-hashmaps-slow" name="why-are-rusts-hashmaps-slow">
Perché le <code>HashMap</code> di Rust sono così lente?
</a></h3>

<p>Di base, le <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a> di Rust utilizzano l’algoritmo di hashing <a href="https://131002.net/siphash/">SipHash</a>, progettato per prevenire <a href="http://programmingisterrible.com/post/40620375793/hash-table-denial-of-service-attacks-revisited">attacchi basati sulla collisione di hash</a> fornendo comunque <a href="https://www.reddit.com/r/rust/comments/3hw9zf/rust_hasher_comparisons/cub4oh6">un livello di prestazione accettabile in una varietà di compiti</a>.</p>

<p>Mentre SipHash <a href="http://cglab.ca/%7Eabeinges/blah/hash-rs/">dimostra prestazioni competitive</a> in molti casi, un caso in cui è conclamatamente lento è in presenza di chiavi corte, come ad esempio i numeri interi.
Questo perché i programmatori Rust spesso incontrano problemi prestazionali con <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a>.
<a href="https://crates.io/crates/fnv">FNV hasher</a> è spesso consigliato per queste casistiche, tenendo comunque in considerazione che non possiede le stesse caratteristiche di protezione dagli attacchi a collisione di SipHash.</p>

<h3><a href="#why-is-there-no-integrated-benchmarking" name="why-is-there-no-integrated-benchmarking">
Perchè non esiste una piattaforma integrata di misurazione delle prestazioni?
</a></h3>

<p>Esiste ma è riservata al canale di rilascio “nightly”.
Progettiamo di costituire un sistema integrato e modulare di misurazione delle prestazioni ma nel frattempo il sistema attuale è <a href="https://github.com/rust-lang/rust/issues/29553">considerato instabile</a>.</p>

<h3><a href="#does-rust-do-tail-call-optimization" name="does-rust-do-tail-call-optimization">
Rust ottimizza le tail-call?
</a></h3>

<p>In generale, no.
Le ottimizzazioni delle tail-call sono riservate ad alcune <a href="http://llvm.org/docs/CodeGenerator.html#sibling-call-optimization">condizioni particolari</a>
ma <a href="https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html">non è assicurato</a>.
Siccome è sempre stata una funzionalità desiderata, Rust ha riservato l’identificatore (<code class="highlighter-rouge">become</code>),
anche se non è ancora chiaro se sia possibile questa ottimizzazione o se verrà implementata.
Era stata <a href="https://github.com/rust-lang/rfcs/pull/81">proposta un’estensione</a> che avrebbe permesso di eliminare le tail-call in alcuni casi ma al momento è stata rimandata.</p>

<h3><a href="#does-rust-have-a-runtime" name="does-rust-have-a-runtime">
Rust ha un ambiente di esecuzione?
</a></h3>

<p>Non nel senso tipico utilizzato da linguaggi come il Java ma componenti della libreria standard di Rust possono essere considerati un “ambiente di esecuzione”, fornendo controlli per heap, backtrace, unwinding, e stack.
C’è un piccolo quantitativo <a href="https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src/libstd/rt.rs#L43">di codice di inizializzazione</a> che viene eseguito prima della funzione <code class="highlighter-rouge">main</code>.
La libreria standard di Rust inoltre è collegata alla libreria standard del C, che effettua una simile <a href="http://www.embecosm.com/appnotes/ean9/html/ch05s02.html">inizializzazione</a>.
Il codice di Rust può essere compilato anche senza la libreria standard, in questo caso il suo ambiente è circa equivalente a quello del C.</p>

<h2 id="syntax">Sintassi</h2>

<h3><a href="#why-curly-braces" name="why-curly-braces">
Perchè le parentesi graffe? La sintassi di Rust non poteva ispirarsi a Haskell o a Python?
</a></h3>

<p>L’utilizzo delle graffe per indicare blocchi di codice è una scelta comune in una moltitudine di linguaggi di programmazione e l’adesione di Rust allo standard è utile per le persone già familiari con lo stile.</p>

<p>Le graffe consentono inoltre una sintassi più flessibile per il programmatore e per un preprocessore più semplice nel compilatore.</p>

<h3><a href="#why-brackets-around-blocks" name="why-brackets-around-blocks">
Posso omettere le parentesi nelle condizioni degli <code>if</code>,
perché allora devo mettere delle parentesi attorno a righe di codice singole?
Perché non è ammesso lo stile del C?
</a></h3>

<p>Mentre il C richiede parentesi obbligatorie per le condizioni dell’istruzione <code class="highlighter-rouge">if</code> ma rende le parentesi del corpo opzionali,
Rust fa la scelta opposta per i suoi <code class="highlighter-rouge">if</code>.
Questo lascia la condizione separata chiaramente dal corpo e evita il pericolo delle parentesi opzionali,
che possono condurre in inganno durante la modifica del codice, come il famoso errore <a href="https://gotofail.com/">goto fail</a> commesso da Apple.</p>

<h3><a href="#why-no-literal-syntax-for-dictionaries" name="why-no-literal-syntax-for-dictionaries">
Perché non c'è una sintassi letterale per i dizionari?
</a></h3>

<p>Le scelte stilistiche di Rust sono per limitare la dimensione del <em>linguaggio</em> contemporaneamente sfruttando potenti <em>librerie</em>.
Anche se Rust fornisce una sintassi per inizializzare array e costanti letterali stringa, questi sono gli unici tipi collezione inseriti nel linguaggio.
Tutti gli altri tipi definiti da librerie, incluso l’onnipresente <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a> utilizzano macro per la loro inizializzazione, ad esempio la macro <a href="https://doc.rust-lang.org/stable/std/macro.vec!.html"><code class="highlighter-rouge">vec!</code></a>.</p>

<p>La scelta di utilizzare le macro di Rust per facilitare l’inizializzazione di collezioni verrà probabilmente estesa a altre collezioni in futuro, permettendo inizializzazioni semplici non solo di
<a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a> e <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a>, ma anche altri tipi di collezioni come <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code class="highlighter-rouge">BTreeMap</code></a>.
Nel frattempo, se vuoi una sintassi più comoda per inizializzare le collezioni, puoi <a href="https://stackoverflow.com/questions/27582739/how-do-i-create-a-hashmap-literal">creare la tua macro</a> per fornirla.</p>

<h3><a href="#when-should-i-use-an-implicit-return" name="when-should-i-use-an-implicit-return">
Quando dovrei utilizzare un ritorno implicito?
</a></h3>

<p>Rust è un linguaggio molto espression-centrico e i ritorni impliciti fanno parte del suo design.
Costrutti come gli <code class="highlighter-rouge">if</code>, i <code class="highlighter-rouge">match</code>e i normali blocchi sono tutte espressioni in Rust.</p>

<p>Ad esempio, il codice seguente controlla se un <a href="https://doc.rust-lang.org/stable/std/primitive.i64.html"><code class="highlighter-rouge">i64</code></a> è dispari, ritornando il risultato semplicamente fornendone il risultato:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">dispari</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">true</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">false</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Anche se può essere ulteriormente semplificato come qui:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">dispari</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In ciascun esempio, l’ultima riga rappresenta il valore di ritorno della funzione.
Risulta importante specificare che se una funzione termina con un punto e virgola il suo tipo di ritorno sarà <code class="highlighter-rouge">()</code>, indicando nessun valore di ritorno.
I ritorni impliciti funzionano quindi esclusivamente in assenza del punto e virgola.</p>

<p>I ritorni espliciti sono utilizzati solo se un ritorno implicito risulta impossibile perchè si desidera ritornare un valore prima della fine del corpo della funzione.
Mentre ciascuna delle funzioni sopra avrebbe potuto includere un <code class="highlighter-rouge">return</code> e un punto e virgola, questa aggiunta sarebbe inutilmente prolissa e inconsistente con le convenzioni del codice Rust.</p>

<h3><a href="#why-arent-function-signatures-inferred" name="why-arent-function-signatures-inferred">
Perchè i tipi delle funzioni non sono dedotti automaticamente?
</a></h3>

<p>In Rust le dichiarazioni sono tendelzialmente accompagnate da un tipo esplicito, mentre nel codice i tipi vengono dedotti.
Ci sono multiple ragioni per questa scelta:</p>

<ul>
  <li>Dichiarazioni obbligatorie dei tipi obbligano a mantenere un’interfaccia stabile a livello di modulo e di pacchetto.</li>
  <li>I tipi facilitano la comprensione del codice per il programmatore, eliminando la necessità di un ambiente di sviluppo che possa desumere il tipo analizzando il codice dell’intero pacchetto:
il tipo è sempre disponibile nelle vicinanze e in modo esplicito.</li>
  <li>Semplifica gli algoritmi che gesticono la deduzione dei tipi, visto che può essere analizzata una funzione alla volta.</li>
</ul>

<h3><a href="#why-does-match-have-to-be-exhaustive" name="why-does-match-have-to-be-exhaustive">
Perché <code>match</code> deve essere così completo?
</a></h3>

<p>Per assistere nelle modifiche e in chiarezza.</p>

<p>Prima di tutto, se ogni possibilità viene coperta da un <code class="highlighter-rouge">match</code>, l’aggiunta di varianti a un <code class="highlighter-rouge">enum</code> causerà un errore di compilazione, invece che un problema durante l’esecuzione.
Questo tipo di assistenza permette di modificare il codice Rust liberamente e senza paura.</p>

<p>Secondariamente, il controllo dettagliato rende esplicito il caso predefinito: in generale l’unico modo per creare un <code class="highlighter-rouge">match</code> non esaustivo sarebbe di far andare in errore il processo se non viene incontrato alcun valore previsto.
Le versioni iniziali di Rust non prevedevano la completezza di <code class="highlighter-rouge">match</code> ed è stato accertato che questa scelta ha causato una moltitudine di problematiche.</p>

<p>Risulta comunque semplice ignorare tutti i casi non specificati usando il carattere speciale <code class="highlighter-rouge">_</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">match</span> <span class="n">val</span><span class="nf">.fai_qualcosa</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">Gatto</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
    <span class="n">_</span>        <span class="k">=&gt;</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="numerics">Numerici</h2>

<h3><a href="#which-type-of-float-should-i-use" name="which-type-of-float-should-i-use">
Quale dovrei scegliere tra <code>f32</code> e <code>f64</code> per i calcoli in virgola mobile?
</a></h3>

<p>La scelta dipende dallo scopo del programma.</p>

<p>Se ciò che conta è la precisione massima, <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a> è da preferire.
Se invece si vuole minimizzare l’impatto in memoria e l’efficienza, ignorando la precisione persa, <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a> è più appropriato.
Svolgere operazioni sugli <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a> è generalmente più veloce, anche in piattaforme a 64-bit.
Come esempio, la grafica sfrutta tipicamente gli <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a> perché richiede alte prestazioni e i numeri in virgola mobile a 32-bit bastano per rappresentare i pixel a schermo.</p>

<p>Nel dubbio, scegli <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a> per una maggiore precisione.</p>

<h3><a href="#why-cant-i-compare-floats" name="why-cant-i-compare-floats">
Perchè non posso comparare i numeri a virgola mobile o usarli come chiave per un <code>HashMap</code> o un <code>BTreeMap</code>?
</a></h3>

<p>I numeri a virgola mobile si possono comparare con gli operatori <code class="highlighter-rouge">==</code>, <code class="highlighter-rouge">!=</code>, <code class="highlighter-rouge">&lt;</code>, <code class="highlighter-rouge">&lt;=</code>, <code class="highlighter-rouge">&gt;</code>, e <code class="highlighter-rouge">&gt;=</code> , e attraverso la funzione <code class="highlighter-rouge">partial_cmp()</code>.
<code class="highlighter-rouge">==</code> e <code class="highlighter-rouge">!=</code> possiedono il tratto <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html"><code class="highlighter-rouge">PartialEq</code></a>, mentre <code class="highlighter-rouge">&lt;</code>, <code class="highlighter-rouge">&lt;=</code>, <code class="highlighter-rouge">&gt;</code>, <code class="highlighter-rouge">&gt;=</code>, e <code class="highlighter-rouge">partial_cmp()</code> possiedono il tratto <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialOrd.html"><code class="highlighter-rouge">PartialOrd</code></a>.</p>

<p>I numeri a virgola mobile non sono confrontabili con la funzione <code class="highlighter-rouge">cmp()</code>, possidente il tratto <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code class="highlighter-rouge">Ord</code></a>, dato che i numeri a virgola mobile non costituiscono insieme totalmente ordinato.
Inoltre non esiste relazione di uguaglianza completa numeri a virgola mobile e quindi non implementano il tratto<a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code class="highlighter-rouge">Eq</code></a>.</p>

<p>Non esiste l’ordinamento totale o l’uguaglianza tra numeri a virgola mobile a causa del valore <a href="https://en.wikipedia.org/wiki/NaN"><code class="highlighter-rouge">NaN</code></a> che non è minore, maggiore o uguale di alcun altro numero o se stesso.</p>

<p>Visto che i numeri a virgola mobile non implementano i tratti <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code class="highlighter-rouge">Eq</code></a> o <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code class="highlighter-rouge">Ord</code></a>, non sono utilizzabili nei tipi le cui limitazioni esigono l’implementazione di queste caratteristiche, come <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html"><code class="highlighter-rouge">BTreeMap</code></a> o <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a>.
Questo è importante perché questi tipi <em>suppongono</em> che le chiavi forniscano relazioni di ordinamento totale o di uguaglianza, a pena di malfunzionamenti.</p>

<p>Esiste <a href="https://crates.io/crates/ordered-float">un pacchetto</a> che racchiude <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a> e <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a> in modo da fornire i tratti <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code class="highlighter-rouge">Ord</code></a> e <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code class="highlighter-rouge">Eq</code></a> che potrebbe assistere in certi casi.</p>

<h3><a href="#how-can-i-convert-between-numeric-types" name="how-can-i-convert-between-numeric-types">
Come posso convertire tra i tipi numerici?
</a></h3>

<p>Ci sono due modi: la parola chiave <code class="highlighter-rouge">as</code>, che esegue una semplice conversione per tipi primitivi e i tratti <a href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html"><code class="highlighter-rouge">Into</code></a> e <a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code class="highlighter-rouge">From</code></a>,
che sono implementati per una serie di conversioni tra tipi numerici (e che anche tu puoi implementare sui tuoi tipi).
I tratti <a href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html"><code class="highlighter-rouge">Into</code></a> e <a href="https://doc.rust-lang.org/stable/std/convert/trait.From.html"><code class="highlighter-rouge">From</code></a> sono implementati esclusivamente per le conversioni prive di perdita, qundi ad esempio, <code class="highlighter-rouge">f64::from(0f32)</code> funziona mentre <code class="highlighter-rouge">f32::from(0f64)</code> no.
D’altro canto, <code class="highlighter-rouge">as</code> convertirà tra qualsiasi coppia di tipi primitivi, effettuando i necessari troncamenti..</p>

<h3><a href="#why-doesnt-rust-have-increment-and-decrement-operators" name="why-doesnt-rust-have-increment-and-decrement-operators">
Perchè Rust non possiede operatori per il decremento e incremento?
</a></h3>

<p>Gli operatori di preincremento e postincremento (e relativi opposti equivalenti), anche se convenienti presentano una discreta complessità;
Richiedono una conoscenza dell’ordine di esecuzione e spesso conducono a piccoli problemi e comportamenti anormali in C e C++.
<code class="highlighter-rouge">x = x + 1</code> o <code class="highlighter-rouge">x += 1</code> è leggermente più prolisso ma chiaro.</p>

<h2 id="strings">Stringhe</h2>

<h3><a href="#how-to-convert-string-or-vec-to-slice" name="how-to-convert-string-or-vec-to-slice">
Come posso convertire una <code>String</code> o un <code>Vec&lt;T&gt;</code> a una partizione (<code>&amp;str</code> e <code>&amp;[T]</code>)?
</a></h3>

<p>Solitamente, puoi passare un riferimento a una <code class="highlighter-rouge">String</code> o ad un <code class="highlighter-rouge">Vec&lt;T&gt;</code> ovunque ci si aspetti una partizione.
Utilizzando le <a href="https://doc.rust-lang.org/stable/book/deref-coercions.html">costrizione da de-riferimento</a>, <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> e <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a> verrano automaticamente ridotti alle rispettive partizioni quando passate come riferimento tramite <code class="highlighter-rouge">&amp;</code> o <code class="highlighter-rouge">&amp; mut</code>.</p>

<p>I metodi implementati su <code class="highlighter-rouge">&amp;str</code> e <code class="highlighter-rouge">&amp;[T]</code> possono essere utilizzati direttamente su <code class="highlighter-rouge">String</code> e <code class="highlighter-rouge">Vec&lt;T&gt;</code>.
Ad esempio <code class="highlighter-rouge">una_stringa.trim()</code> funzionerà anche se <code class="highlighter-rouge">trim</code> è un metodo su <code class="highlighter-rouge">&amp;str</code> e <code class="highlighter-rouge">una_stringa</code> è una <code class="highlighter-rouge">String</code>.</p>

<p>In alcuni casi, come nella programmazione generica è necessario convertire manualmente, questa operazione è effettuabile utilizzando l’operatore di partizione, in questo modo: <code class="highlighter-rouge">&amp;mio_vettore[..]</code>.</p>

<h3><a href="#how-to-convert-between-str-and-string" name="how-to-convert-between-str-and-string">
Come posso convertire una <code>&amp;str</code> in <code>String</code> e viceversa?
</a></h3>

<p>Il metodo <a href="https://doc.rust-lang.org/stable/std/string/trait.ToString.html#tymethod.to_string"><code class="highlighter-rouge">to_string()</code></a> converte una <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">&amp;str</code></a> in una <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> e le <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> sono automaticamente convertite in <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">&amp;str</code></a> quando ne acquisisci un riferimento.
Entrambe sono visibili nell’esempio seguente:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"Maria Rossi"</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="nf">saluta</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">saluta</span><span class="p">(</span><span class="n">nome</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Ciao {}!"</span><span class="p">,</span> <span class="n">nome</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><a href="#what-are-the-differences-between-str-and-string" name="what-are-the-differences-between-str-and-string">
In cosa differiscono i due tipi stringa?
</a></h3>

<p><a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> è un’area di memoria allocata nell’heap, di byte UTF-8.
Le <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> mutabili possono essere modificate, espanendosi se necessario.
<a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">&amp;str</code></a> è una “vista” di capacità fissata in una <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> allocata altrove, generalmente nel heap, in caso di partizioni riferite a <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>, o in memoria statica, per le costanti letterali.</p>

<p><a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">&amp;str</code></a> è un tipo primitivo implementato nel linguaggio Rust, mentre <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> è implementato dalla libreria standard.</p>

<h3><a href="#how-do-i-do-o1-character-access-in-a-string" name="how-do-i-do-o1-character-access-in-a-string">
Come accedo ai caratteri di una <code>String</code> con complessità asintottica O(1)?
</a></h3>

<p>Non è possibile. Senza una chiara comprensione di cosa intendi per “carattere” e una pre-elaborazione della stringa per ritrovare l’indice del carattere desiderato.</p>

<p>Le stringhe in Rust sono codificate in UTF-8.
Un singolo carattere UTF-8 non è obbligatoriamente grande un singolo byte come sarebbe una stringa codificata in ASCII.
Ogni byte è chiamato una “unità di codice” (nello UTF-16, le unità di codice sono di 2 byte, nello UTF-32 sono di 4 byte).
I “punti di codice” sono composti di una o più unità di codice, combinate in “gruppi di grafemi” che fedelmente ricalcano il concetto tradizionale di caratteri.</p>

<p>Anche con la possibilità di indicizzare i byte in una stringa UTF-8, non puoi accedere all’<code class="highlighter-rouge">i</code>-esimo elemento del gruppo di grafemi in un tempo costante.
Ad ogni modo, se conosci a quale byte si trova il punto di codice o gruppo di grafemi desiderato, quindi <em>puoi</em> accedervi in tempo costante.
Le funzioni, incluse <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.find"><code class="highlighter-rouge">str::find()</code></a> e le espressioni regolari ritornano indici dei byte, facilitando questo tipo di accesso.</p>

<h3><a href="#why-are-strings-utf-8" name="why-are-strings-utf-8">
Perchè le stringhe sono UTF-8?
</a></h3>

<p>Le <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">str</code></a> sono UTF-8 perché nel mondo questa codifica è frequente - specialmente in trasmissioni di rete, che ignorano l’ordine di bit della piattaforma - pensiamo quindi sia meglio che il trattamento standard dell’I/O non preveda la ricodifica in entrambe le direzioni.</p>

<p>Questo significa che individuare un particolare punto di codice Unicode dentro una stringa è un’operazione O(n), anche se, conoscendo l’indice del byte ci si può accedere in un tempo O(1) come previsto.
Sotto un certo punto di vista questo è chiaramente sconveniente; ma d’altro canto questo problema è pieno di compromessi e vorremmo sottolineare alcune precisazioni importanti:</p>

<p>Scorrere una <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">str</code></a> per valori della codifica ASCII può essere fatto in sicurezza byte per byte,
utilizzando <a href="https://doc.rust-lang.org/stable/std/primitive.str.html#method.as_bytes"><code class="highlighter-rouge">.as_bytes()</code></a> ed estraendo <a href="https://doc.rust-lang.org/stable/std/primitive.u8.html"><code class="highlighter-rouge">u8</code></a> con un costo <code class="highlighter-rouge">O(1)</code> e producendo valori che possono essere trasformati e comparati con la codifica ASCII con il tipo <a href="https://doc.rust-lang.org/stable/std/primitive.char.html"><code class="highlighter-rouge">char</code></a>.
Quindi se per (ad esempio) vogliamo andare a capo ad ogni <code class="highlighter-rouge">'\n'</code>, una ricerca byte a byte continua a essere funzionante, grazie alla flessibilità dello standard UTF-8.</p>

<p>La maggior parte delle operazioni orientate ai caratteri sul testo funzionano su presupposti molto ristretti come ad esempio l’esclusione dei caratteri non ASCII.
Anche in questo caso all’esterno della codifica ASCII si tende a utilizzare comunque un algoritmo complesso(con complessità non costante) per determinare i bordi di caratteri, parole e paragrafi.
Noi consigliamo di utilizzare un algoritmo “onesto”, approvato da Unicode e adattato al linguaggio da considerare.</p>

<p>Il tipo <a href="https://doc.rust-lang.org/stable/std/primitive.char.html"><code class="highlighter-rouge">char</code></a> è UTF-32.
Se hai la certezza di dover richiedere l’analisi di un “punto di codice” alla volta è semplicissimo scrivere <code class="highlighter-rouge">type wstr = [char]</code> e caricarci dentro una <a href="https://doc.rust-lang.org/stable/std/primitive.str.html"><code class="highlighter-rouge">str</code></a> in un solo passaggio, per poi lavorare con il nuovo <code class="highlighter-rouge">wstr</code>.
In altre parole: il fatto che il linguaggio non decodifichi a UTF-32 come prima opzione non ti deve inibire da decodificare(o ri-codificare per il processo inverso) i caratteri se necessiti di lavorare in quella codifica.</p>

<p>Per una spiegazione più dettagliata su perché UTF-8 è preferibile rispetto a UTF-16 o UTF-32, leggi il <a href="http://utf8everywhere.org/">manifesto di UTF-8 Everywhere</a>.</p>

<h3><a href="#what-string-type-should-i-use" name="what-string-type-should-i-use">
Quale tipo stringa dovrei usare?
</a></h3>

<p>Rust ha quattro paia di tipi stringa, <a href="http://www.suspectsemantics.com/blog/2016/03/27/string-types-in-rust/">ciascuno assolve un ruolo distinto</a>.
In ciascun paio, c’è un tipo stringa “posseduto” e un tipo stringa “partizione”.
I tipi sono suddivisi così:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left"> </th>
      <th style="text-align: left">tipo “Partizione”</th>
      <th style="text-align: left">tipo “Posseduto”</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">UTF-8</td>
      <td style="text-align: left"><code class="highlighter-rouge">str</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">String</code></td>
    </tr>
    <tr>
      <td style="text-align: left">Compatibile con il SO</td>
      <td style="text-align: left"><code class="highlighter-rouge">OsStr</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">OsString</code></td>
    </tr>
    <tr>
      <td style="text-align: left">Compatibile con il C</td>
      <td style="text-align: left"><code class="highlighter-rouge">CStr</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">CString</code></td>
    </tr>
    <tr>
      <td style="text-align: left">Percorso di sistema</td>
      <td style="text-align: left"><code class="highlighter-rouge">Path</code></td>
      <td style="text-align: left"><code class="highlighter-rouge">PathBuf</code></td>
    </tr>
  </tbody>
</table>

<p>I diversi tipi di stringa di Rust assolvono ruoli diversi.
<code class="highlighter-rouge">String</code> e <code class="highlighter-rouge">str</code> sono stringhe ad uso generico codificate in in UTF-8.
<code class="highlighter-rouge">OsString</code> e <code class="highlighter-rouge">OsStr</code> sono codificati a seconda della piattaforma corrente e sono utilizzati per interagire con il sistema operativo.
<code class="highlighter-rouge">CString</code> e <code class="highlighter-rouge">CStr</code> sono l’equivalente in Rust delle stringhe del C, si utilizzano nelle chiamate FFI, mentre <code class="highlighter-rouge">PathBuf</code> e <code class="highlighter-rouge">Path</code> sono un’aggiunta di <code class="highlighter-rouge">OsString</code> e <code class="highlighter-rouge">OsStr</code> ed implementano metodi specifici alla manipolazione di percorsi.</p>

<h3><a href="#why-are-there-multiple-types-of-strings" name="why-are-there-multiple-types-of-strings">
Come faccio a scrivere una funzione che accetti sia <code>&amp;str</code> che <code>String</code>?
</a></h3>

<p>Ci sono diverse opzioni, a seconda delle necessità della funzione:</p>

<ul>
  <li>Se la funzione richiede una stringa posseduta ma vuole accettare una qualsiasi stringa utilizza la restrizione al tratto <code class="highlighter-rouge">Into&lt;String&gt;</code>.</li>
  <li>Se la funzione richiede una partizione di stringa ma vuole accettare una qualsiasi stringa utilizza la restrizione al tratto <code class="highlighter-rouge">AsRef&lt;str&gt;</code>.</li>
  <li>Se alla funzione non interessa del tipo di stringa e vuole gestire uniformemente le due possibilità utilizza il tipo <code class="highlighter-rouge">Cow&lt;str&gt;.</code></li>
</ul>

<p><strong>Usare <code class="highlighter-rouge">Into&lt;String&gt;</code></strong></p>

<p>In questo esempio, la funzione accetta sia stringhe possedute che partizioni di stringa o facendo nulla o convertendo l’ingresso in stringa posseduta.
Nota che la conversione deve essere fatta esplicitamente e non succede altrimenti.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">accetta_entrambe</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">Into</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.into</span><span class="p">();</span>   <span class="c">// Questo converte s in una `String`.</span>
    <span class="c">// ... il resto della funzione</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Usare <code class="highlighter-rouge">AsRef&lt;str&gt;</code></strong></p>

<p>In questo esempio, la funzione accetta sia stringhe possedute che partizioni di stringa o facendo nulla o convertendo l’ingresso in una partizione di stringa.
Questo viene fatto automaticamente prendendo l’ingresso per riferimento, come qui:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">accetta_entrambe</span><span class="o">&lt;</span><span class="n">S</span><span class="p">:</span> <span class="n">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ... il corpo della funzione</span>
<span class="p">}</span>
</code></pre>
</div>

<p><strong>Usare <code class="highlighter-rouge">Cow&lt;str&gt;</code></strong></p>

<p>In questo esempio, la funzione accetta un <code class="highlighter-rouge">Cow&lt;str&gt;</code>, che non è un tipo generico ma un contenitore, contenente o una stringa posseduta o una partizione di stringa all’occorrenza.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">accetta_cow</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Cow</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ... il corpo della funzione</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="collections">Collezioni</h2>

<h3><a href="#can-i-implement-linked-lists-in-rust" name="can-i-implement-linked-lists-in-rust">
Posso implementare efficientemente strutture dati come vettori e liste concatenate in Rust?
</a></h3>

<p>If vuoi implementare queste strutture dati per utilizzarle in altri programmi non è necessario, essendo implementazioni efficienti di queste strutture già disponibili nella libreria standard.</p>

<p>Se invece, <a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">vuoi solo imparare</a>, probabilmente dovrai entrare nel codice insicuro.
Anche se è <em>possibile</em> implementarle solo con codice sicuro, le prestazioni sarebbero probabilmente peggiori di come sarebbe stato lo stesso codice con l’utilizzo di codice insicuro.
La semplice ragione per ciò è che le strutture dati come vettori e liste concatenate fanno affidamento a operazioni su puntatori e memoria che sono proibiti nel Rust sicuro.</p>

<p>Per esempio, una lista concatenata doppia richiede due riferimenti mutabili a ciascun nodo ma questo viola le regole di Rust sull’esclusività dei riferimenti mutabili.
Si può risolvere il problema utilizzando <a href="https://doc.rust-lang.org/stable/std/rc/struct.Weak.html"><code class="highlighter-rouge">Weak&lt;T&gt;</code></a>, ma le prestazioni sarebbero probabilmente peggiori di quanto desiderato.
Con il codice insicuro puoi ignorare le regole di esclusività ma devi verificare manualmente che il tuo codice non introduca violazioni nella sua gestione della memoria.</p>

<h3><a href="#how-can-i-iterate-over-a-collection-without-consuming-it" name="how-can-i-iterate-over-a-collection-without-consuming-it">
Come posso iterare una collezione senza muoverla o consumarla?
</a></h3>

<p>Il modo più semplice è utilizzare l’implementazione del tratto <a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code class="highlighter-rouge">IntoIterator</code></a>.
Ecco qui un esempio con <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">&amp;Vec</code></a>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="k">for</span> <span class="n">oggetto</span> <span class="n">in</span> <span class="o">&amp;</span><span class="n">v</span> <span class="p">{</span>
    <span class="nd">print!</span><span class="p">(</span><span class="s">"{} "</span><span class="p">,</span> <span class="n">oggetto</span><span class="p">);</span>
<span class="p">}</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Lunghezza: {}"</span><span class="p">,</span> <span class="n">v</span><span class="nf">.len</span><span class="p">());</span>
</code></pre>
</div>

<p>I cicli <code class="highlighter-rouge">for</code> in Rust chiamano la funzione <code class="highlighter-rouge">into_iter()</code> (definita dal tratto <a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code class="highlighter-rouge">IntoIterator</code></a>) per qualsiasi cosa stiano analizzando.
Tutto ciò che implementa il tratto <a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code class="highlighter-rouge">IntoIterator</code></a> può essere traversato con un ciclo <code class="highlighter-rouge">for</code>.
<a href="https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html"><code class="highlighter-rouge">IntoIterator</code></a> è implementato per <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">&amp;Vec</code></a> e <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">&amp;mut Vec</code></a>, obbligando l’iteratore generato da <code class="highlighter-rouge">into_iter()</code> a prendere in prestito i contenuti della collezione, al posto di consumarli o muoverli.
Lo stesso è vero per le altre collezioni della libreria standard.</p>

<p>Se si desidera un iteratore che muova/consumi i valori, basta scrivere lo stesso ciclo <code class="highlighter-rouge">for</code> omettendo <code class="highlighter-rouge">&amp;</code> o <code class="highlighter-rouge">&amp;mut</code>.</p>

<p>Se si necessita accesso diretto all’iteratore, vi si può usualmente accedere invocando il metodo <code class="highlighter-rouge">iter()</code>.</p>

<h3><a href="#why-do-i-need-to-type-the-array-size-in-the-array-declaration" name="why-do-i-need-to-type-the-array-size-in-the-array-declaration">
Perchè devo inserire la dimensione del vettore alla sua dichiarazione?
</a></h3>

<p>Non è necessario. Se dichiari direttamente un vettore, la dimensione è dedotta dal numero di elementi. Se invece dichiari una funzione che accetta un vettore di dimensione prefissata il compilatore deve avere modo di sapere quale sarà la dimensione di quel vettore.</p>

<p>Una cosa da notare è che attualmente Rust non offere generici su array di dimensioni diverse.
Se desideri quindi accettare un contenitore continuo di un numero variabile di valori, utilizza <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a> o una partizione (a seconda che tu richieda il possesso o no).</p>

<h2 id="ownership">Possesso</h2>

<h3><a href="#how-can-i-implement-a-data-structure-that-contains-cycles" name="how-can-i-implement-a-data-structure-that-contains-cycles">
Come posso implementare un grafo o altra struttura contenente cicli?
</a></h3>

<p>Esistono almeno quattro diverse opzioni (largamente discusse in <a href="http://cglab.ca/~abeinges/blah/too-many-lists/book/">Too Many Linked Lists</a>):</p>

<ul>
  <li>Puoi implementarlo usando <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code class="highlighter-rouge">Rc</code></a> e <a href="https://doc.rust-lang.org/stable/std/rc/struct.Weak.html"><code class="highlighter-rouge">Weak</code></a> per permettere il possesso condiviso dei nodi,
anche se questo approccio richiede la gestione della memoria.</li>
  <li>Puoi implementarlo usando codice <code class="highlighter-rouge">unsafe</code> e i puntatori.
Anche se efficiente questo metodo ignora i paradigmi di sicurezza di Rust.</li>
  <li>Usando vettori indici al loro interno. Esistono <a href="http://smallcultfollowing.com/babysteps/blog/2015/04/06/modeling-graphs-in-rust-using-vector-indices/">diversi</a> modi <a href="https://featherweightmusings.blogspot.com/2015/04/graphs-in-rust.html">disponibili</a>, esempi e spiegazioni di questo metodo.</li>
  <li>Usando <a href="https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html"><code class="highlighter-rouge">UnsafeCell</code></a>. Esistono <a href="https://github.com/nrc/r4cppp/blob/master/graphs/README.md#node-and-unsafecell">spiegazioni e codice</a> per questo metodo.</li>
</ul>

<h3><a href="#how-can-i-define-a-struct-that-contains-a-reference-to-one-of-its-own-fields" name="how-can-i-define-a-struct-that-contains-a-reference-to-one-of-its-own-fields">
Come posso definire una struttura che contiene un riferimento a un suo campo?
</a></h3>

<p>Si può fare ma è inutile.
La struttura diventa permanentemente prestata a se stessa e quindi non può essere copiata.
Ecco del codice per capire meglio:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">Cell</span><span class="p">;</span>

<span class="cp">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Immobile</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Cell</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="err">'</span><span class="n">a</span> <span class="nb">u32</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">test</span> <span class="o">=</span> <span class="n">Immobile</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nn">Cell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">test</span><span class="py">.y</span><span class="nf">.set</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="py">.x</span><span class="p">));</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">test</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><a href="#what-is-the-difference-between-consuming-and-moving" name="what-is-the-difference-between-consuming-and-moving">
Che differenza sussiste tra passare per valore, consumare, spostare e trasferire la proprietà?
</a></h3>

<p>Sono parole diverse per dire la stessa cosa.
In tutti i casi significa che il valore è stato trasferito a un nuovo proprietario, o che la proprietà è stata trasferita dal possessore originario, che quindi non può più accedervi.
Se un tipo implementa il tratto <code class="highlighter-rouge">Copy</code>, il valore del proprietario originale non viene invalidato e può essere utilizzato nuovamente.</p>

<h3><a href="#why-can-values-of-some-types-by-reused-while-others-are-consumed" name="why-can-values-of-some-types-by-reused-while-others-are-consumed">
Perchè alcuni valori di alcuni tipi possono essere utilizzati dopo il passaggio a una funzione mentre il riutilizzo di valori di altri tipi genera errori?
</a></h3>

<p>Se un tipo implementa il tratto <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a>, esso verrà copiato durante il suo passaggio a una funzione.
Tutti i tipi numerici in Rust implementano <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a> ma le strutture in maniera predefinita non implementano <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a>, quindi invece di essere copiate sono mosse.
Ciò implica che la struttura non possa più essere utilizzata altrove, se non viene ritornata dalla funzione tramite un <code class="highlighter-rouge">return</code>.</p>

<h3><a href="#how-do-you-deal-with-a-use-of-moved-value-error" name="how-do-you-deal-with-a-use-of-moved-value-error">
Come si gestice l'errore "utilizzo di un valore spostato"?
</a></h3>

<p>Questo errore significa che il valore che stai cercando di utilizzare è stato trasferito a un nuovo proprietario.
La prima cosa da controllare in questo caso è se il trasferimento era davvero necessario: se il valore era stato mosso a una funzione, potrebbe essere possibile riscriverla per utilizzare un riferimento invece che il trasferimento, ad esempio.
Altrimenti se il tipo mosso implementa il tratto <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code class="highlighter-rouge">Clone</code></a>, chiamare <code class="highlighter-rouge">clone()</code> su di esso prima di muoverlo trasferirà una sua copia, mantenendo l’originale disponibile per utilizzi futuri.
Nota che la clonazione di un valore dovrebbe essere l’ultima spiaggia, essendo la procedura di clonazione costosa e causa di allocazioni di memoria.</p>

<p>Se il valore mosso è uno dei tuoi tipi personalizzati, considera implementare il tratto <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a> (per la copia implicita al posto del trasferimento) o <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code class="highlighter-rouge">Clone</code></a> (copia esplicita).
<a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a> è generalmente implementato con la direttiva <code class="highlighter-rouge">#[derive(Copy, Clone)]</code> (<a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">Copy</code></a> richiede <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code class="highlighter-rouge">Clone</code></a>), e <a href="https://doc.rust-lang.org/stable/std/clone/trait.Clone.html#tymethod.clone"><code class="highlighter-rouge">Clone</code></a> con la direttiva <code class="highlighter-rouge">#[derive(Clone)]</code>.</p>

<p>Se nulla di tutto questo è possibile, probabilmente devi modificare la funzione che ha acquisito il possesso per fare in modo che restituisca la proprietà alla sua uscita.</p>

<h3><a href="#what-are-the-rules-for-different-self-types-in-methods" name="what-are-the-rules-for-different-self-types-in-methods">
Quali regole disciplinano l'utilizzo di <code>self</code>, <code>&amp;self</code> o <code>&amp;mut self</code> nella dichiarazione di un metodo?
</a></h3>

<ul>
  <li>Usa <code class="highlighter-rouge">self</code> quando una funzione deve consumare il valore</li>
  <li>Usa <code class="highlighter-rouge">&amp;self</code> quando una funzione necessita solo di una copia di sola lettura del valore</li>
  <li>Usa <code class="highlighter-rouge">&amp;mut self</code> quando una funzione necessita di modificare un valore ma senza consumarlo</li>
</ul>

<h3><a href="#how-can-i-understand-the-borrow-checker" name="how-can-i-understand-the-borrow-checker">
Come faccio a comprendere il gestore dei prestiti?
</a></h3>

<p>Il gestore dei prestiti, mentre analizza il codice, applica poche semplici regole, che sono illustrate nella sezione del libro di Rust <a href="https://doc.rust-lang.org/stable/book/references-and-borrowing.html#the-rules">dedicata ai prestiti</a>.
Queste regole sono:</p>

<blockquote>
  <p>Prima cosa, ogni prestito deve durare per un periodo di tempo non superiore alla vita del possessore originale.
Seconda cosa, puoi avere accesso a uno o l’altro di questi due tipi di prestiti, ma non a entrambi contemporaneamente:</p>

  <ul>
    <li>uno o più riferimenti (&amp;T) a una risorsa.</li>
    <li>esattamente un riferimento mutabile (&amp;mut T)</li>
  </ul>
</blockquote>

<p>Nonostante le regole siano molto semplici, seguirle correttamente può essere molto complicato, specialmente per coloro che non sono abitutati a ragionare in termini di campi di esistenza e possesso.</p>

<p>La prima regola è comprendere che il gestore dei prestiti identifica veramente gli errori che produce: molto lavoro è stato profuso per renderlo un assistente di qualità nella risoluzione delle problematiche che individua.
Quando incontri un problema segnalato dal gestore dei prestiti, il primo passo è di leggere lentamente e con attenzione l’errore e poi approcciarsi al codice una volta compreso davvero l’errore descritto.</p>

<p>Il secondo passo è cercare di familiarizzare con i tipi contenitore associati con i concetti di possesso e mutabilità forniti dalla libreria standard di Rust, includendo <a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html"><code class="highlighter-rouge">Cell</code></a>, <a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html"><code class="highlighter-rouge">RefCell</code></a> e <a href="https://doc.rust-lang.org/stable/std/borrow/enum.Cow.html"><code class="highlighter-rouge">Cow</code></a>.
Questi utili e necessari strumenti possono aiutare ad esprimere efficientemente alcune situazioni complesse di possesso e mutabilità.</p>

<p>La singola cosa più importante nella comprensione del gestore dei prestiti è la pratica.
La potente analisi statica fatta da Rust è particolare e molto differente da molte esperienze di programmazione precedente.
Ci vorrà un po’ di tempo per acquisire la giusta tranquillità.</p>

<p>Se ti ritrovi in difficoltà con il gestore dei prestiti, oppure hai finito la pazienza, sentiti libero di chiedere un aiuto alla <a href="community.html">comunità di Rust</a>.</p>

<h3><a href="#when-is-rc-useful" name="when-is-rc-useful">
Quando può venire utile utilizzare una <code>Rc</code>?
</a></h3>

<p>Questo è coperto dalla documentazione ufficiale per <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code class="highlighter-rouge">Rc</code></a> il tipo di puntatore non-atomico utilizzante il reference counting di Rust.
In breve, <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code class="highlighter-rouge">Rc</code></a> e il suo cugino, amico del multithreading <a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code class="highlighter-rouge">Arc</code></a> sono utili per indicare possesso condiviso e vengono deallocati automaticamente dal sistema quando nessuno vi accede.</p>

<h3><a href="#how-do-i-return-a-closure-from-a-function" name="how-do-i-return-a-closure-from-a-function">
Come posso ritornare una chiusura da una funzione?
</a></h3>

<p>Per ritornare una chiusura da una funzione, essa deve essere una “chiusura da movimento”, ovvero che essa deve essere dichiarata dalla parola <code class="highlighter-rouge">move</code>.
Come <a href="https://doc.rust-lang.org/book/closures.html#move-closures">illustrato nel libro di Rust</a>, questo fornisce alla chiusura la sua copia delle variabili catturate, indipendentemente dal quadro di allocazione del chiamante.
Altrimenti, ritornare da una chiusura sarebbe insicuro, visto che permetterebbe di accedere a variabili non più disponibili; detto in un altro modo: permetterebbe di leggere dati da locazioni di memoria errate.
La chiusura deve anche essere racchiusa in un <a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html"><code class="highlighter-rouge">Box</code></a>, in modo da essere allocata nella heap.
Puoi saperne di più <a href="https://doc.rust-lang.org/book/closures.html#returning-closures">nel libro</a>.</p>

<h3><a href="#what-are-deref-coercions" name="what-are-deref-coercions">
Cos'è un deriferimento forzato e come funziona?
</a></h3>

<p>Un <a href="https://doc.rust-lang.org/book/deref-coercions.html">deriferimento forzato</a> è una pratica conversione automatica di delle referenze
a puntatori (es., <code class="highlighter-rouge">&amp;Rc&lt;T&gt;</code> or <code class="highlighter-rouge">&amp;Box&lt;T&gt;</code>) a referenze ai loro contenuti
(es., <code class="highlighter-rouge">&amp;T</code>).
Il deriferimento forzato esiste per rendere l’utilizzo di Rust più comodo e sono implementati dal tratto <a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code class="highlighter-rouge">Deref</code></a>.</p>

<p>Una implementazione di <code class="highlighter-rouge">Deref</code> indica che il tipo implementante potrebbe essere convertito in un valore con una chiamata al metodo <code class="highlighter-rouge">deref</code>, che prende un riferimento immutabile al tipo chiamante e ritorna un riferimento(senza violare peró il campo di esistenza) del tipo obiettivo.
L’operatore <code class="highlighter-rouge">*</code>, se utilizzato come prefisso è un metodo più veloce per accedere a <code class="highlighter-rouge">deref</code>.</p>

<p>Sono chiamate “forzature” a causa delle regole spiegate qui <a href="https://doc.rust-lang.org/stable/book/deref-coercions.html">nel libro di Rust</a>:</p>

<blockquote>
  <p>Se hai un tipo <code class="highlighter-rouge">U</code> ed esso implementa <code class="highlighter-rouge">Deref&lt;Target=T&gt;</code>, i valori <code class="highlighter-rouge">&amp;U</code> verranno automaticamente convertiti in <code class="highlighter-rouge">&amp;T</code>.</p>
</blockquote>

<p>Ad esempio, se hai un <code class="highlighter-rouge">&amp;Rc&lt;String&gt;</code>, esso verrà forzato per questa regola a <code class="highlighter-rouge">&amp;String</code>, che può essere forzato anche a <code class="highlighter-rouge">&amp;str</code> nello stesso modo.
Quindi se una funzione accettasse un parametro <code class="highlighter-rouge">&amp;str</code>, puoi passare direttamente un <code class="highlighter-rouge">&amp;Rc&lt;String&gt;</code> e tutte le forzature e verranno gestite automaticamente dal tratto <code class="highlighter-rouge">Deref</code>.</p>

<p>I tipici deriferimenti forzati sono:</p>

<ul>
  <li><code class="highlighter-rouge">&amp;Rc&lt;T&gt;</code> a <code class="highlighter-rouge">&amp;T</code></li>
  <li><code class="highlighter-rouge">&amp;Box&lt;T&gt;</code> a <code class="highlighter-rouge">&amp;T</code></li>
  <li><code class="highlighter-rouge">&amp;Arc&lt;T&gt;</code> a <code class="highlighter-rouge">&amp;T</code></li>
  <li><code class="highlighter-rouge">&amp;Vec&lt;T&gt;</code> a <code class="highlighter-rouge">&amp;[T]</code></li>
  <li><code class="highlighter-rouge">&amp;String</code> a <code class="highlighter-rouge">&amp;str</code></li>
</ul>

<h2 id="lifetimes">Campi di esistenza</h2>

<h3><a href="#why-lifetimes" name="why-lifetimes">
Perchè i campi di esistenza?
</a></h3>

<p>I campi di esistenza sono la soluzione di Rust al problema della sicurezza della memoria.
Questi consentono a Rust di assicurare la sicurezza della memoria senza i costi prestazionali della garbage collection.
Sono basati su una serie di articoli accademici che possono essere trovati nel <a href="https://doc.rust-lang.org/stable/book/bibliography.html#type-system">libro di Rust</a>.</p>

<h3><a href="#why-is-the-lifetime-syntax-the-way-it-is" name="why-is-the-lifetime-syntax-the-way-it-is">
Perché la sintassi dei campi di esistenza è fatta così?
</a></h3>

<p>La sintassi <code class="highlighter-rouge">'a</code> proviene dalla famiglia ML di linguaggi di programmazione, dove <code class="highlighter-rouge">'a</code> viene utilizzato per indicare un parametro di tipo generico.
In Rust, la sintassi doveva rappresentare qualcosa di univoco, chiaramente visibile e integrato con le altre dichiarazioni dei tipi insieme ai vari tratti e riferimenti.
Sono state prese in considerazione anche altre scelte ma nessuna sintassi alternativa si è dimostrata chiaramente migliore.</p>

<h3><a href="#how-do-i-return-a-borrow-to-something-i-created-from-a-function" name="how-do-i-return-a-borrow-to-something-i-created-from-a-function">
Come posso ritornare un prestito a qualcosa che ho creato in una funzione?
</a></h3>

<p>Devi assicurarti che il campo di esistenza del valore prestato sia più lungo di quello della funzione.
Puoi ottenere questo effetto puoi assegnare il campo di esistenza dell’uscita a quello di un parametro di ingresso come qui:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">type</span> <span class="n">Gruppo</span> <span class="o">=</span> <span class="n">TypedArena</span><span class="o">&lt;</span><span class="n">Cosa</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c">// (Il campo di esistenza sotto è esplicitato esclusivamente</span>
<span class="c">/// per facilitarne la comprensione; esso può essere omesso</span>
<span class="c">// tramite le regole di elisione consultabili in un'altra</span>
<span class="c">// risposta presente in questa pagina)</span>

<span class="k">fn</span> <span class="n">crea_prestato</span><span class="o">&lt;</span><span class="err">'</span><span class="n">a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gruppo</span><span class="p">:</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="n">Gruppo</span><span class="p">,</span>
                       <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
                       <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="err">'</span><span class="n">a</span> <span class="n">Cosa</span> <span class="p">{</span>
    <span class="n">gruppo</span><span class="nf">.alloc</span><span class="p">(</span><span class="n">Cosa</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Un’alternativa è eliminare interamente il riferimento ritornando un valore posseduto come <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">buon_compleanno</span><span class="p">(</span><span class="n">nome</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="nd">format!</span><span class="p">(</span><span class="s">"Ciao {}! Hai {} anni!"</span><span class="p">,</span> <span class="n">nome</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Questo approccio è più semplice ma spesso genera allocazioni in memoria non necessarie.</p>

<h3><a href="#when-are-lifetimes-required-to-be-explicit" name="when-are-lifetimes-required-to-be-explicit">
Perchè alcuni riferimenti hanno un campo di esistenza, come <code>&amp;'a T</code> e altri no, tipo <code>&amp;T</code>?
</a></h3>

<p>In realtà, <em>tutti</em> i riferimenti hanno un campo di esistenza ma nella maggior parte dei casi non
ti devi preoccupare di gestirlo esplicitamente. Le regole sono le seguenti:</p>

<ol>
  <li>Nel corpo di una funzione non devi mai specificare un campo di esistenza esplicitamente;
il valore corretto dovrebbe essere sempre dedotto correttamente.</li>
  <li>Nella <em>dichiarazione</em> di una funzione (ad esempio, nei tipi dei suoi parametri
o il suo tipo di ritorno), <em>potresti</em> dover specificare un campo di esistenza manualmente.
I campi di esistenza in questo contesto utilizzano un semplice metodo chiamato
<a href="https://doc.rust-lang.org/book/lifetimes.html#lifetime-elision">“elisione del campo di esistenza”</a>,
che a sua volta consiste in queste tre regole:
    <ul>
      <li>Ciascun campo di esistenza eliso nei parametri di una funzione diviene un campo di esistenza distinto.</li>
      <li>Se vi è esattamente un singolo campo di esistenza in ingresso, eliso o no, quel campo di esistenza
 viene assegnato a tutti i campi di esistenza elisi utilizzati per i valori di ritorno di quella funzione.</li>
      <li>Se ci sono più campi di esistenza in ingresso ma uno di quelli è un <code class="highlighter-rouge">&amp;self</code> o un <code class="highlighter-rouge">&amp;mut self</code>, il campo di esistenza
 di <code class="highlighter-rouge">self</code> viene assegnato a tutti i campi di esistenza di uscita.</li>
    </ul>
  </li>
  <li>Se si sta definendo una <code class="highlighter-rouge">struct</code> o <code class="highlighter-rouge">enum</code> i campi di esistenza sono da dichiarare espressamente.</li>
</ol>

<p>Se queste regole danno origine a un errore di compilazione, il compilatore di Rust fornirà un messaggio di errore indicante l’errore e anche una potenziale soluzione basata sugli algoritmi di deduzione.</p>

<h3><a href="#how-can-rust-guarantee-no-null-pointers" name="how-can-rust-guarantee-no-null-pointers">
Come può Rust garantire l'assenza di "puntatori nulli" e "puntatori sospesi"?
</a></h3>

<p>L’unico modo di creare un valore <code class="highlighter-rouge">&amp;Cosa</code> or <code class="highlighter-rouge">&amp;mut Cosa</code> è di specificare un valore preesistente di tipo <code class="highlighter-rouge">Coso</code> a cui la referenza deve fare riferimento.
Il riferimento in questo modo ottiene in prestito il valore originale per un determinato blocco di codice(il campo di esistenza del riferimento) e il valore prestato non può essere spostato o distrutto per tutta la durata del prestito.</p>

<h3><a href="#how-do-i-express-the-absense-of-a-value-without-null" name="how-do-i-express-the-absense-of-a-value-without-null">
Come faccio a indicare l'assenza di un valore senza utilizzare <code>null</code>?
</a></h3>

<p>Puoi fare ciò con il tipo <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code class="highlighter-rouge">Option</code></a> che può alternativamente essere <code class="highlighter-rouge">Some(T)</code> o <code class="highlighter-rouge">None</code>.
<code class="highlighter-rouge">Some(T)</code> indica che un valore di tipo <code class="highlighter-rouge">T</code> è contenuto all’interno, mentre <code class="highlighter-rouge">None</code> ne indica l’assenza.</p>

<h2 id="generics">Generici</h2>

<h3><a href="#what-is-monomorphisation" name="what-is-monomorphisation">
Cos'è la "monomorfizzazione"?
</a></h3>

<p>La monomorfizzazione specializza ciascun utilizzo di una funzione(o struttura) generica in base ai tipi di parametri di ciascuna chiamata(o agli utilizzi della struttura).</p>

<p>Durante la monomorfizzazione viene generata una nuova versione specializzata della funzione per ciascun set univoco di tipi.
Questa strategia, già utilizzata nel C++, genera del codice macchina efficiente, specializzato per ciascuna chiamata e invocato staticamente, con lo svantaggio che una funzione istanziata con tanti tipi diversi
può dare luogo a molta duplicazione nel codice generato, generando quindi eseguibili più grandi rispetto ad altre strategie di traduzione.</p>

<p>Le funzioni che accettano <a href="https://doc.rust-lang.org/book/trait-objects.html">oggetti caratterizzati solo da tratti</a> invece dei tipi non sono soggette alla monomorfizzazione.
Invece, i metodi invocati su oggetti tratto sono gestiti dinamicamente durante l’esecuzione.</p>

<h3><a href="#whats-the-difference-between-a-function-and-a-closure-that-doesnt-capture" name="whats-the-difference-between-a-function-and-a-closure-that-doesnt-capture">
Qual è la differenza tra una funzione e una chiusura che non cattura nessuna variabile?
</a></h3>

<p>Le funzioni e le chiusure si utilizzano allo stesso modo ma hanno una gestione differente in fase di esecuzione a causa di una implementazione diversa.</p>

<p>Le funzioni sono un costrutto fondamentale del linguaggio, mentre le chiusure sono essenzialemente un modo più semplice per indicare uno di questi tre tratti: <a href="https://doc.rust-lang.org/stable/std/ops/trait.Fn.html"><code class="highlighter-rouge">Fn</code></a>, <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnMut.html"><code class="highlighter-rouge">FnMut</code></a> e <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html"><code class="highlighter-rouge">FnOnce</code></a>.
Quando scrivi una chiusura, il compilatore di Rust automaticamente provvede a generare una struttura implementante il tratto più idoneo tra quei tre e a catturare le variabili corrette come membri,
generando anche la possibilità di utilizzare la struttura come una funzione. Le strutture, al contrario, non catturano alcuna variabile.</p>

<p>La fondamentale differenza tra questi tratti è come acquisiscono il parametro <code class="highlighter-rouge">self</code>.
<a href="https://doc.rust-lang.org/stable/std/ops/trait.Fn.html"><code class="highlighter-rouge">Fn</code></a> prende <code class="highlighter-rouge">&amp;self</code>, <a href="https://doc.rust-lang.org/stable/std/ops/trait.FnMut.html"><code class="highlighter-rouge">FnMut</code></a> prende <code class="highlighter-rouge">&amp;mut self</code> mentre<a href="https://doc.rust-lang.org/stable/std/ops/trait.FnOnce.html"><code class="highlighter-rouge">FnOnce</code></a> prende <code class="highlighter-rouge">self</code>.</p>

<p>Anche se una cattura non cattura alcuna variabile di ambiente, viene rappresentata in fase di esecuzione tramite due puntatori, come qualsiasi altra chiusura.</p>

<h3><a href="#what-are-higher-kinded-types" name="what-are-higher-kinded-types">
Cosa sono i tipi di più alto livello, perché sono richiesti e perché Rust non li implementa?
</a></h3>

<p>I tipi di più alto livello sono tipi con parametri non specificati. I costruttori di tipi come <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec</code></a>, <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a> e <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap</code></a> sono tutti esempi di tipi di più alto livello:
ciascuno richiede alcuni tipi aggiuntivi per poter denotare effettivamente il suo tipo, come nel caso di <code class="highlighter-rouge">Vec&lt;u32&gt;</code>.
Il supporto per i tipi di alto livello significa che questi tipi “incompleti” possono essere utilizzati ovunque possano essere utilizzati anche i tipi “completi”, non escludendo le funzioni generiche.</p>

<p>Ogni tipo completo, come <a href="https://doc.rust-lang.org/stable/std/primitive.i32.html"><code class="highlighter-rouge">i32</code></a>, <a href="https://doc.rust-lang.org/stable/std/primitive.bool.html"><code class="highlighter-rouge">bool</code></a>, o <a href="https://doc.rust-lang.org/stable/std/primitive.char.html"><code class="highlighter-rouge">char</code></a> è di tipo <code class="highlighter-rouge">*</code> (questa notazione deriva dalla teoria correlata con il sistema dei tipi).
Un tipo a parametro singolo, come <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec&lt;T&gt;</code></a> è invece <code class="highlighter-rouge">* -&gt; *</code>, ovvero che vec <a href="https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"><code class="highlighter-rouge">Vec&lt;T&gt;</code></a> accetta un tipo completo come <a href="https://doc.rust-lang.org/stable/std/primitive.i32.html"><code class="highlighter-rouge">i32</code></a> e ritorna il tipo completo <code class="highlighter-rouge">Vec&lt;i32&gt;</code>.
Un tipo con tre parametri, come <a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html"><code class="highlighter-rouge">HashMap&lt;K, V, S&gt;</code></a> è di tipo <code class="highlighter-rouge">* -&gt; * -&gt; * -&gt; *</code> perché accetta tre tipi completi (come <a href="https://doc.rust-lang.org/stable/std/primitive.i32.html"><code class="highlighter-rouge">i32</code></a>, <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html"><code class="highlighter-rouge">String</code></a> e <a href="https://doc.rust-lang.org/stable/std/collections/hash_map/struct.RandomState.html"><code class="highlighter-rouge">RandomState</code></a>) per generare un nuovo tipo completo <code class="highlighter-rouge">HashMap&lt;i32, String, RandomState&gt;</code>.</p>

<p>In aggiunta a questi esempi, i costruttori di tipo possono accettare dei parametri sul <em>campo di esistenza</em>, che denoteremo con <code class="highlighter-rouge">Lt</code>.
Ad esempio <code class="highlighter-rouge">slice::Iter</code> ha il tipo <code class="highlighter-rouge">Lt -&gt; * -&gt; *</code>, perchè va istanziato ad esempio come <code class="highlighter-rouge">Iter&lt;'a, u32&gt;</code>.</p>

<p>La mancanza di supporto per i tipi di più alto livello rende difficile scrivere alcuni tipi di codice generico.
Risulta particolarmente problematico astrarre su concetti come gli iteratori, dato che essi sono spesso parametrizzati nei confronti di uno specifico campo di esistenza.
Queste premesse hanno impedito la creazione di tratti che astraggano ulteriormente le collezioni presenti in Rust.</p>

<p>Un altro esempio frequente è da ricercare nei concetti di functor e monad, entrambi dei quali sono costruttori di tipi, invece che tipi individuali.</p>

<p>Rust al momento non possiede supporto per i tipi di più alto livello perché non è stato prioritizzato lo sviluppo di questa funzione rispetto ad altre funzionalità che rispecchiano meglio gli obiettivi del progetto.
Essendo la progettazione di funzionalità importanti come queste un campo minato, vorremmo procedere con cautela, non c’è un’altra ragione particolare sul perché Rust non possiede questa funzionalità.</p>

<h3><a href="#what-do-named-type-parameters-in-generic-types-mean" name="what-do-named-type-parameters-in-generic-types-mean">
Cosa significano i parametri fatti tipo <code>&lt;T=Foo&gt;</code> nel codice generico?
</a></h3>

<p>Questi sono chiamati <a href="https://doc.rust-lang.org/stable/book/associated-types.html">tipi associati</a>, permettono di indicare limitazioni di tratto non esprimibili con un costrutto <code class="highlighter-rouge">where</code>.
Ad esempio, una limitazione generica <code class="highlighter-rouge">X: Bar&lt;T=Foo&gt;</code> significa che <code class="highlighter-rouge">X</code> deve implementare il tratto <code class="highlighter-rouge">Bar</code> e in tale implementazione di bar <code class="highlighter-rouge">Bar</code>, <code class="highlighter-rouge">X</code> deve scegliere <code class="highlighter-rouge">Foo</code> come il tipo associato di <code class="highlighter-rouge">Bar</code>, <code class="highlighter-rouge">T</code>.
Gli esempi in cui una limitazione di tal genere non è esprimibile con un costrutto <code class="highlighter-rouge">where</code> includono i tipi tratto come <code class="highlighter-rouge">Box&lt;Bar&lt;T=Foo&gt;&gt;</code>.</p>

<p>I tipi associati esistono perché spesso i generici riguardano famiglie di tipi, dove un tipo determina tutti gli altri membri. Per esempio, un tratto per grafi potrebbe avere per <code class="highlighter-rouge">Self</code> il grafo stesso e avere dei tipi correlati per i suoi nodi e vertici. Ciascun tipo grafo identifica univocamente i tipi associato, rendendo molto più conciso lavorare con questi tipi di strutture e fornendo anche una migliore gestione sulla deduzione dei tipi in molti casi.</p>

<h3><a href="#how-do-i-overload-operators" name="how-do-i-overload-operators">
Posso sovrascrivere gli operatore? Se sì, quali? Come faccio?
</a></h3>

<p>Puoi personalizzare l’implementazione di una varietà di operatori utilizzando i loro tratti associati: <a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html"><code class="highlighter-rouge">Add</code></a> per il  <code class="highlighter-rouge">+</code>, <a href="https://doc.rust-lang.org/stable/std/ops/trait.Mul.html"><code class="highlighter-rouge">Mul</code></a> per il <code class="highlighter-rouge">*</code> e via dicendo. Si può fare così:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nb">Add</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Foo</span><span class="p">;</span>

<span class="k">impl</span> <span class="nb">Add</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Uscita</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="n">Foo</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">Self</span><span class="p">::</span><span class="n">Uscita</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Sommando!"</span><span class="p">);</span>
        <span class="k">self</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>I seguenti operatori possono essere sovrascritti:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Operation</th>
      <th style="text-align: left">Trait</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">+</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Add.html"><code class="highlighter-rouge">Add</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">+=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.AddAssign.html"><code class="highlighter-rouge">AddAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">- binario</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Sub.html"><code class="highlighter-rouge">Sub</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">-=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.SubAssign.html"><code class="highlighter-rouge">SubAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">*</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Mul.html"><code class="highlighter-rouge">Mul</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">*=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.MulAssign.html"><code class="highlighter-rouge">MulAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">/</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Div.html"><code class="highlighter-rouge">Div</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">/=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.DivAssign.html"><code class="highlighter-rouge">DivAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">unary -</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Neg.html"><code class="highlighter-rouge">Neg</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">%</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Rem.html"><code class="highlighter-rouge">Rem</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">%=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.RemAssign.html"><code class="highlighter-rouge">RemAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&amp;</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitAnd.html"><code class="highlighter-rouge">BitAnd</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code>&#124;</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitOr.html"><code class="highlighter-rouge">BitOr</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code>&#124;</code>=</td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitOrAssign.html"><code class="highlighter-rouge">BitOrAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">^</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitXor.html"><code class="highlighter-rouge">BitXor</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">^=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.BitXorAssign.html"><code class="highlighter-rouge">BitXorAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">!</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Not.html"><code class="highlighter-rouge">Not</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;&lt;</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Shl.html"><code class="highlighter-rouge">Shl</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&lt;&lt;=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.ShlAssign.html"><code class="highlighter-rouge">ShlAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&gt;&gt;</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Shr.html"><code class="highlighter-rouge">Shr</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">&gt;&gt;=</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.ShrAssign.html"><code class="highlighter-rouge">ShrAssign</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">*</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Deref.html"><code class="highlighter-rouge">Deref</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">mut *</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.DerefMut.html"><code class="highlighter-rouge">DerefMut</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">[]</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.Index.html"><code class="highlighter-rouge">Index</code></a></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="highlighter-rouge">mut []</code></td>
      <td style="text-align: left"><a href="https://doc.rust-lang.org/stable/std/ops/trait.IndexMut.html"><code class="highlighter-rouge">IndexMut</code></a></td>
    </tr>
  </tbody>
</table>

<h3><a href="#why-the-split-between-eq-partialeq-and-ord-partialord" name="why-the-split-between-eq-partialeq-and-ord-partialord">
Cosa distingue <code>Eq</code>/<code>PartialEq</code> e <code>Ord</code>/<code>PartialOrd</code>?
</a></h3>

<p>Ci sono alcuni tipi in Rust i cui valori sono solo parzialmente ordinati oppure hanno relazioni di equivalenza parziali. Ordinamento parziale significa che potrebbero esserci valori di quel tipo che non sono né più piccoli né più grandi di un altro. Uguaglianza parziale significa che ci potrebbero essere dei valori di un certo tipo che non sono uguali a loro stessi.</p>

<p>I tipi a virgola mobile (<a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a> e <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a>) sono un buon esempio di questo. Ogni tipo in virgola mobile potrebbe avere il valore <code class="highlighter-rouge">NaN</code> (ovvero “non un numero”). <code class="highlighter-rouge">NaN</code> non è uguale a se stesso (<code class="highlighter-rouge">NaN == NaN</code> è falso) e nemmeno più grande o più piccolo di un qualsiasi valore.
Di conseguenza sia <a href="https://doc.rust-lang.org/stable/std/primitive.f32.html"><code class="highlighter-rouge">f32</code></a> che <a href="https://doc.rust-lang.org/stable/std/primitive.f64.html"><code class="highlighter-rouge">f64</code></a> implementano <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialOrd.html"><code class="highlighter-rouge">PartialOrd</code></a> e <a href="https://doc.rust-lang.org/stable/std/cmp/trait.PartialEq.html"><code class="highlighter-rouge">PartialEq</code></a> ma non <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html"><code class="highlighter-rouge">Ord</code></a> e nemmeno <a href="https://doc.rust-lang.org/stable/std/cmp/trait.Eq.html"><code class="highlighter-rouge">Eq</code></a>.</p>

<p>Come spiegato nella <a href="#why-cant-i-compare-floats">precedente domanda sui numeri in virgola mobile</a>, queste distinzioni sono importanti perchè alcune collezioni fanno affidamento sul totale ordinamento/uguaglianza per funzionare.</p>

<h2 id="input-output">Input / Output</h2>

<h3><a href="#how-do-i-read-a-file-into-a-string" name="how-do-i-read-a-file-into-a-string">
Come legge un file in una <code>String</code>?
</a></h3>

<p>Usando la funzione <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.read_to_string"><code class="highlighter-rouge">read_to_string()</code></a>, definita nel tratto <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html"><code class="highlighter-rouge">Read</code></a> di <a href="https://doc.rust-lang.org/stable/std/io/index.html"><code class="highlighter-rouge">std::io</code></a>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">leggi_file</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="nd">try!</span><span class="p">(</span><span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">));</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nd">try!</span><span class="p">(</span><span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">));</span>  <span class="c">// `s` contiene il contenuto di "foo.txt"</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">match</span> <span class="nf">leggi_file</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Letti i contenuti del file!"</span><span class="p">),</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"Non sono riuscito a leggere i contenuti del file, errore: {}"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
    <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><a href="#how-do-i-read-file-input-efficiently" name="how-do-i-read-file-input-efficiently">
Come leggo un file efficientemente?
</a></h3>

<p>Il tipo <a href="https://doc.rust-lang.org/stable/std/fs/struct.File.html"><code class="highlighter-rouge">File</code></a> implementa il tratto <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html"><code class="highlighter-rouge">Read</code></a> che include una moltitudine di funzioni per leggere e scrivere, includendo <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#tymethod.read"><code class="highlighter-rouge">read()</code></a>, <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.read_to_end"><code class="highlighter-rouge">read_to_end()</code></a>, <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.bytes"><code class="highlighter-rouge">bytes()</code></a>, <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.chars"><code class="highlighter-rouge">chars()</code></a> e <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.take"><code class="highlighter-rouge">take()</code></a>.
Ciascuna di queste funzioni legge un pochino dal file.
<a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#tymethod.read"><code class="highlighter-rouge">read()</code></a> legge quanto il sottostante sistema di input fornisce.
<a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.read_to_end"><code class="highlighter-rouge">read_to_end()</code></a> legge l’intero buffer in un vettore, allocando lo spazio necessario. <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.bytes"><code class="highlighter-rouge">bytes()</code></a> e <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.chars"><code class="highlighter-rouge">chars()</code></a> permettono rispettivamente di iterare sui byte e caratteri del file, respectively.
Inoltre, <a href="https://doc.rust-lang.org/stable/std/io/trait.Read.html#method.take"><code class="highlighter-rouge">take()</code></a> permette di leggere un numero arbitrario di byte dal file. Insieme, questi metodi permettono di leggere efficientemente ogni tipo di file.</p>

<p>Per le letture con buffer utilizza la struttura <a href="https://doc.rust-lang.org/stable/std/io/struct.BufReader.html"><code class="highlighter-rouge">BufReader</code></a> che aiuta a ridurre il carico di lavoro al sistema durante la lettura.</p>

<h3><a href="#how-do-i-do-asynchronous-input-output-in-rust" name="how-do-i-do-asynchronous-input-output-in-rust">
Come faccio a gestire input e output asincroni in Rust?
</a></h3>

<p>Ci sono molte librerie che forniscono input / output asincroni in Rust, come <a href="https://github.com/dpc/mioco">mioco</a>, <a href="https://github.com/zonyitoo/coio-rs">coio-rs</a> e <a href="https://github.com/tailhook/rotor">rotor</a>.</p>

<h3><a href="#how-do-i-get-command-line-arguments" name="how-do-i-get-command-line-arguments">
Come faccio a prendere parametri da riga di comando in Rust?
</a></h3>

<p>Il modo più semplice è utilizzare <a href="https://doc.rust-lang.org/stable/std/env/struct.Args.html"><code class="highlighter-rouge">Args</code></a>, che fornisce un iteratore sui parametri da riga di comando.</p>

<p>Se stai cercando qualcosa di più potente, ci sono <a href="https://crates.io/keywords/argument">una serie di librerie disponbili su crates.io</a>.</p>

<h2 id="error-handling">Gestione degli errori</h2>

<h3><a href="#why-doesnt-rust-have-exceptions" name="why-doesnt-rust-have-exceptions">
Perchè Rust non ha le eccezioni?
</a></h3>

<p>Le eccezioni complicano la comprensione del flusso del programma, esprimono validità o invalidità all’infuori del sistema dei tipi e funzionano male in ambienti multicore(un obiettivo primario per Rust).</p>

<p>Rust preferisce un approccio alla gestione degli errori basato sui tipi come <a href="https://doc.rust-lang.org/stable/book/error-handling.html">spiegato nel dettaglio nel libro</a>.
Questo è più compatibile con il flusso di controllo tipico di Rust, la concorrenza e tutto il resto.</p>

<h3><a href="#whats-the-deal-with-unwrap" name="whats-the-deal-with-unwrap">
Perché c'è <code>unwrap()</code> ovunque?
</a></h3>

<p><code class="highlighter-rouge">unwrap()</code> è una funzione che estrae il valore da una <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code class="highlighter-rouge">Option</code></a> o un <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a> e va in errore se il valore non è presente.</p>

<p><code class="highlighter-rouge">unwrap()</code> non dovrebbe essere il tuo modo principale per gestire gli errori prevedibili, tipo un errore nell’input dell’utente.
Nel tuo codice, dovrebbe essere trattato come test per la non nullità di un valore, pena il mandare in errore il programma.</p>

<p>Viene utilizzato anche per provare velocemente quando non si vuole ancora gestire tutti i casi o negli articoli, quando la gestione degli errori potrebbe distrarre dal resto.</p>

<h3><a href="#why-do-i-get-errors-with-try" name="why-do-i-get-errors-with-try">
Perchè ottengo un errore quando provo a eseguire codice di esempio che utilizza la macro <code>try!</code>?
</a></h3>

<p>Quasi sicuramente è un problema con il tipo ritornato dalla funzione. La macro <a href="https://doc.rust-lang.org/stable/std/macro.try!.html"><code class="highlighter-rouge">try!</code></a> estrae un valore da <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a> o ritorna con l’errore portato in <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a>.
Ció significa che <a href="https://doc.rust-lang.org/stable/std/macro.try!.html"><code class="highlighter-rouge">try</code></a> vale solo per le funzioni che ritornano un <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a>, dove il tipo costruito <code class="highlighter-rouge">Err</code> implementa <code class="highlighter-rouge">From::from(err)</code>.
In particolare ciò significa che la macro <a href="https://doc.rust-lang.org/stable/std/macro.try!.html"><code class="highlighter-rouge">try!</code></a> non è utlizzabile nella funzione <code class="highlighter-rouge">main</code>.</p>

<h3><a href="#error-handling-without-result" name="error-handling-without-result">
Esiste un modo più semplice per gestire gli errori rispetto a inserire <code>Result</code> ovunque?
</a></h3>

<p>Se stai cercando un modo per evitare di gestire i <a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a> nel codice di altre persone, puoi sempre utilizzare <a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.unwrap"><code class="highlighter-rouge">unwrap()</code></a> ma probabilmente non è ciò che desideri.
<a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code class="highlighter-rouge">Result</code></a> indica che una qualche operazione potrebbe fallire. Richiedere di gestire esplicitamente questi problemi è uno dei tanti modi in cui Rust incoraggia la scrittura di programmi affidabili.
Rust fornisce degli strumenti come la <a href="https://doc.rust-lang.org/stable/std/macro.try!.html">macro <code class="highlighter-rouge">try!</code></a> per gestire in ergonomia queste situazioni.</p>

<p>Se davvero desideri non gestire un errore, utilizza <a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.unwrap"><code class="highlighter-rouge">unwrap()</code></a> ma sappi che fare ciò implica che il codice arresterà la sua esecuzione in caso di fallimento, usualmente terminando il processo.</p>

<h2 id="concurrency">Concorrenza</h2>

<h3><a href="#can-i-use-static-values-across-threads-without-an-unsafe-block" name="can-i-use-static-values-across-threads-without-an-unsafe-block">
Posso utilizzare valori statici attraverso i thread senza utilizzare <code>unsafe</code>?
</a></h3>

<p>La mutabilità è sicura solo se sincronizzata. Mutare un <a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code class="highlighter-rouge">Mutex</code></a> statico (inizializzato tramite il pacchetto <a href="https://crates.io/crates/lazy_static/">lazy-static</a>) non richiede un blocco di codice <code class="highlighter-rouge">unsafe</code> come non lo richiede la modifica di un <a href="https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicUsize.html"><code class="highlighter-rouge">AtomicUsize</code></a>
(inizializzabile anche senza lazy_static).</p>

<p>Piú in generale, se un tipo implementa il tratto <a href="https://doc.rust-lang.org/stable/std/marker/trait.Sync.html"><code class="highlighter-rouge">Sync</code></a> e non implementa <a href="https://doc.rust-lang.org/stable/std/ops/trait.Drop.html"><code class="highlighter-rouge">Drop</code></a>, esso <a href="https://doc.rust-lang.org/book/const-and-static.html#static">è utilizzabile in una <code class="highlighter-rouge">static</code></a>.</p>

<h2 id="macros">Macro</h2>

<h3><a href="#can-i-write-a-macro-to-generate-identifiers" name="can-i-write-a-macro-to-generate-identifiers">
Posso scrivere una macro per generare identificatori?
</a></h3>

<p>Al momento no.
Le macro di Rust sono <a href="https://en.wikipedia.org/wiki/Hygienic_macro">“hygienic macros”</a> che intenzionalmente evitano la cattura o la creazione di identificatori che potrebbero collidere con altri.
Le loro capacità sono significativamente differenti dagli stili delle macro normalmente associate ai preprocessori C.
Le invocazioni delle macro possono comparire sono il luoghi dove sono esplicitamente supportate: oggetti, dichiarazioni, espressioni e motivi.
Dove per “dichiarazioni” si intende uno spazio dove è possibile inserire un metodo.
Non si possono utilizzare le macro per completare una dichiarazione avventura parzialmente e seguendo la stessa logica, nemmeno per completare dichiarazioni parziali di variabili.</p>

<h2 id="debugging">Debugging e strumentazione</h2>

<h3><a href="#how-do-i-debug-rust-programs" name="how-do-i-debug-rust-programs">
Come si debuggano i programmi Rust?
</a></h3>

<p>Si possono debuggare con <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">gdb</a> o <a href="http://lldb.llvm.org/tutorial.html">lldb</a>, allo stesso modo di C e C++.
In realtà, ogni installazione di Rust viene fornita con uno o entrambi tra rust-gdb e rust-lldb(a seconda della piattaforma). Questi due componenti estendono gdb e lldb con funzioni per permettere una migliore esperienza.</p>

<h3><a href="#how-do-i-locate-a-panic" name="how-do-i-locate-a-panic">
<code>rustc</code> ha detto che del codice della libreria standard è andato in crash, come faccio a trovare il problema?
</a></h3>

<p>Questo errore è spesso causato dall’utilizzo di <a href="https://doc.rust-lang.org/stable/core/option/enum.Option.html#method.unwrap"><code class="highlighter-rouge">unwrap()</code></a> su un <code class="highlighter-rouge">None</code> o <code class="highlighter-rouge">Err</code>.
Abilitando la variabile di ambiente <code class="highlighter-rouge">RUST_BACKTRACE=1</code> potresti ottenere ulteriori informazioni.
Potrebbe essere di aiuto anche la compilazione in modalità debug (predefinita per il comando <code class="highlighter-rouge">cargo build</code>).
Si possono anche utilizzare i sopracitati <code class="highlighter-rouge">rust-gdb</code> o <code class="highlighter-rouge">rust-lldb</code>.</p>

<h3><a href="#what-ide-should-i-use" name="what-ide-should-i-use">
Quale ambiente di sviluppo integrato dovrei utilizzare?
</a></h3>

<p>Ci sono molte opzioni per sviluppare in Rust, tutte illustrate sulla pagina ufficiale <a href="https://forge.rust-lang.org/ides.html">sul supporto agli ambienti di sviluppo</a>.</p>

<h3><a href="#wheres-rustfmt" name="wheres-rustfmt">
<code>gofmt</code> è fantastico. Dov'è <code>rustfmt</code>?
</a></h3>

<p><code class="highlighter-rouge">rustfmt</code> è <a href="https://github.com/rust-lang-nursery/rustfmt">proprio qui</a>, sta venendo sviluppato proprio per permettere di rendere il codice Rust il più semplice e prevedibile possibile.</p>

<h2 id="low-level">Low-Level</h2>

<h3><a href="#how-do-i-memcpy-bytes" name="how-do-i-memcpy-bytes">
Come posso usare <code>memcpy</code>?
</a></h3>

<p>Se vuoi clonare una partizione esistente in sicurezza, puoi usare <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.clone_from_slice"><code class="highlighter-rouge">clone_from_slice</code></a>.</p>

<p>Per copiare byte potenzialmente in conflitto usa <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html"><code class="highlighter-rouge">copy</code></a>.
Per copiare byte non in conflitto usa <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy_nonoverlapping.html"><code class="highlighter-rouge">copy_nonoverlapping</code></a>.
Entrambe le funzioni elencate sono <code class="highlighter-rouge">unsafe</code>, visto che possono eludere le garanzie di sicurezza. Sono quindi da utilizzare con attenzione.</p>

<h3><a href="#does-rust-work-without-the-standard-library" name="does-rust-work-without-the-standard-library">
Può Rust operare senza la sua libreria standard?
</a></h3>

<p>Si. I programmi Rust possono scegliere di non caricare la libreria standard utilizzando l’attributo <code class="highlighter-rouge">#![no_std]</code>.
Una volta impostato, è ancora possibile utilizzare la libreria chiave di Rust, composta esclusivamente da primitivi indipendenti dalla piattaforma di esecuzione. Essa non include IO, concorrenza, allocazioni nella heap, ecc.</p>

<h3><a href="#can-i-write-an-operating-system-in-rust" name="can-i-write-an-operating-system-in-rust">
Posso scrivere un sistema operativo in Rust?
</a></h3>

<p>Si! In realtà al momento <a href="http://wiki.osdev.org/Rust">ci sono molti progetti che stanno facendo proprio questo</a>.</p>

<h3><a href="#how-can-i-write-endian-independent-values" name="how-can-i-write-endian-independent-values">
Come faccio a scrivere o leggere tipi numerici come <code>i32</code> o <code>f64</code> in formato big-endian o little-endian in un file o un flusso di bit?
</a></h3>

<p>Dovresti provare il <a href="http://burntsushi.net/rustdoc/byteorder/">pacchetto byteorder</a>, che fornisce strumenti proprio per quello.</p>

<h3><a href="#does-rust-guarantee-data-layout" name="does-rust-guarantee-data-layout">
Rust garantisce una specifica organizzazione dei dati?
</a></h3>

<p>Non in maniera predefinita. In generale, <code class="highlighter-rouge">enum</code> e <code class="highlighter-rouge">struct</code> non sono definiti.
Questo per permettere al compilatore di effettuare delle ottimizzazioni tipo riutilizzare la distanziatura per il discriminante, compattare le varianti di <code class="highlighter-rouge">enum</code> annidate, riordinare campi per eliminare spaziature, ecc.
Le <code class="highlighter-rouge">enum</code> prive di dati (“simil-C”) possono avere rappresentazione definita. Tali <code class="highlighter-rouge">enum</code> sono facilmente distinte dal fatto che sono semplicemente una lista di nomi senza dati:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">SimilC</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">B</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
    <span class="n">C</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span>
    <span class="n">D</span>
<span class="p">}</span>
</code></pre>
</div>

<p>L’attributo <code class="highlighter-rouge">#[repr(C)]</code> se applicato a tali <code class="highlighter-rouge">enum</code> gli fornisce la stessa rappresentazione che avrebbero avuto nel C.
Questo permette nella maggior parte dei casi di utilizzare le <code class="highlighter-rouge">enum</code> di Rust nella FFI insieme alle <code class="highlighter-rouge">enum</code> fornite dal C.
Tale attributo è applicabile alle <code class="highlighter-rouge">struct</code> per ottenere la stessa rappresentazione delle <code class="highlighter-rouge">struct</code> del C.</p>

<h2 id="cross-platform">Multipiattaforma</h2>

<!--
### How do I build a Windows binary that doesn't display the console window?

TODO: Write this answer.
-->

<!--
### How do I make the console-less binary not crash on panic!?

TODO: Write this answer.
-->

<h3><a href="#how-do-i-express-platform-specific-behavior" name="how-do-i-express-platform-specific-behavior">
Qual'è il modo consigliato per indicare comportamenti specifici a una piattaforma in Rust?
</a></h3>

<p>I comportamenti specifici alla piattaforma sono esprimibili utilizzando <a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">attributi di compilazione condizionale</a> come ad esempio <code class="highlighter-rouge">target_os</code>, <code class="highlighter-rouge">target_family</code>, <code class="highlighter-rouge">target_endian</code>, ecc.</p>

<h3><a href="#can-rust-be-used-for-android-ios-programs" name="can-rust-be-used-for-android-ios-programs">
Posso programmare per Android/iOS in Rust?
</a></h3>

<p>Si! Ci sono già alcuni esempi utilizzanti Rust sia per <a href="https://github.com/tomaka/android-rs-glue">Android</a> che per <a href="https://www.bignerdranch.com/blog/building-an-ios-app-in-rust-part-1/">iOS</a>.
Richiede un pochino di lavoro di preparazione ma Rust funziona correttamente su entrambe le piattaforme.</p>

<h3><a href="#can-i-run-my-rust-program-in-a-web-browser" name="can-i-run-my-rust-program-in-a-web-browser">
Posso eseguire il mio programma Rust in un browser web?
</a></h3>

<p>Non ancora ma sono in corso degli sforzi per permettere di compilare Rust per il web con <a href="https://kripken.github.io/emscripten-site/">Emscripten</a>.</p>

<h3><a href="#how-do-i-cross-compile-rust" name="how-do-i-cross-compile-rust">
Come faccio a usare la compilazione incrociata in Rust?
</a></h3>

<p>La compilazione incrociata è possibile in Rust ma richiede <a href="https://github.com/japaric/rust-cross/blob/master/README.md">alcune accortezze</a> per essere impostata.
Ogni compilatore Rust permette anche la compilazione incrociata ma le librerie necessitano di essere ricompilate per ogni piattaforma obiettivo.</p>

<p>Rust distribuisce <a href="https://static.rust-lang.org/dist/index.html">copie della libreria standard</a> per ciascuna delle piattaforme supportate, ritrovabili nei file <code class="highlighter-rouge">rust-std-*</code> presenti nella pagina citata ma ad oggi non esistono metodi automatizzati per installarle.</p>

<h2 id="modules-and-crates">Moduli e pacchetti</h2>

<h3><a href="#what-is-the-relationship-between-a-module-and-a-crate" name="what-is-the-relationship-between-a-module-and-a-crate">
Come si correlano moduli e pacchetti?
</a></h3>

<ul>
  <li>Un pacchetto è un’unità compilabile, ovvero la minima quantità di codice su cui il compilatore Rust può ancora operare.</li>
  <li>Un modulo è una organizzazione di unità compilabili(anche annidate) all’interno di un pacchetto.</li>
  <li>Un pacchetto contiene un modulo implicito e senza nome nel suo livello più alto.</li>
  <li>Le definizioni ricorsive sono propagabili ai moduli ma non ai pacchetti.</li>
</ul>

<h3><a href="#why-cant-the-rust-compiler-find-a-library-im-using" name="why-cant-the-rust-compiler-find-a-library-im-using">
Perchè il compilatore Rust non riesce a trovare questa libreria che sto importando con <code>use</code>?
</a></h3>

<p>Ci sono diverse possibilità ma un errore comune è non comprendere che le dichiarazioni <code class="highlighter-rouge">use</code> sono relative al livello base del pacchetto.
Prova a riscrivere le tue dichiarazioni in modo che utilizzino i percorsi relativi alla cartella base del pacchett per provare a risolvere il problema.</p>

<p>Ci sono anche <code class="highlighter-rouge">self</code> e <code class="highlighter-rouge">super</code>, che rendono i percorsi di <code class="highlighter-rouge">use</code> riferiti rispettivamente al modulo corrente o al modulo padre.</p>

<p>Per ulteriori informazioni su come utilizzare  <code class="highlighter-rouge">use</code>, leggi il capitolo del libro di Rust <a href="https://doc.rust-lang.org/stable/book/crates-and-modules.html">“Crates and Modules”</a>.</p>

<h3><a href="#why-do-i-have-to-declare-modules-with-mod" name="why-do-i-have-to-declare-modules-with-mod">
Perchè devo dichiarare i file dei moduli con <code>mod</code> al posto di poterli invocare con <code>use</code> direttamente?
</a></h3>

<p>Ci sono due modi per dichiarare i moduli in Rust, in linea o in un altro file. Ecco un esempio:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">// Dentro a main.rs</span>
<span class="k">mod</span> <span class="n">ciao</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"ciao!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">ciao</span><span class="p">::</span><span class="nf">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c">// Dentro a main.rs</span>
<span class="k">mod</span> <span class="n">ciao</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">ciao</span><span class="p">::</span><span class="nf">f</span><span class="p">();</span>
<span class="p">}</span>

<span class="c">// Dentro a ciao.rs</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"ciao!"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Nel primo esempio, il modulo è definito nello stesso file in cui è utilizzato, nel secondo, la dichiarazione del modulo dice al compilatore di cercare o il file <code class="highlighter-rouge">ciao.rs</code> o <code class="highlighter-rouge">ciao/mod.rs</code> e di caricarlo.</p>

<p>Notare la differenza tra <code class="highlighter-rouge">mod</code> e <code class="highlighter-rouge">use</code>: <code class="highlighter-rouge">mod</code> dichiara l’esistenza di un modulo, mentre <code class="highlighter-rouge">use</code> fa riferimento a un modulo dichiarato altrove, rendendone accessibili i suoi contenuti all’interno del modulo corrente.</p>

<h3><a href="#how-do-i-configure-cargo-to-use-a-proxy" name="how-do-i-configure-cargo-to-use-a-proxy">
Come configuro Cargo all'utilizzo di un proxy?
</a></h3>

<p>Come spiegato nella <a href="http://doc.crates.io/config.html">guida alla configurazione di Cargo</a>, può essere impostato un proxy impostando la variabile “proxy” sotto <code class="highlighter-rouge">[http]</code> nel file di configurazione.</p>

<h3><a href="#why-cant-the-compile-find-method-implementations" name="why-cant-the-compile-find-method-implementations">
Perché il compilatore non riesce a trovare l'implementazione del metodo anche se ho già specificato la direttiva <code>use</code> sul pacchetto che la contiene?
</a></h3>

<p>Per i metodi definiti su un tratto, devi esplicitamente importare la dichiarazione del tratto. Questo significa che non è sufficiente importare un modulo dove una <code class="highlighter-rouge">struct</code> implementa un tratto, bisogna importare anche il tratto stesso.</p>

<h3><a href="#why-cant-the-compiler-infer-use-statements" name="why-cant-the-compiler-infer-use-statements">
Perché il compilatore non può capire gli <code>use</code> da solo?
</a></h3>

<p>Probabilmente potrebbe ma non lo vorresti. Mentre in molti casi è probabile che il compilatore possa determinare correttamente il modulo da importare guardando le definizioni questo potrebbe non applicarsi a tutte le casistiche.
Ogni decisione fatta da <code class="highlighter-rouge">rustc</code> genererebbe sopresa e confusione in alcuni casi e Rust preferisce essere esplicito riguardo all’origine dei nomi.</p>

<p>Ad esempio, il compilatore potrebbe decidere che nel casi due identificatori fossero in conflitto sia da preferire l’identificatore la cui dichiarazione è meno recente.
In questo caso sia il modulo <code class="highlighter-rouge">foo</code> che il modulo <code class="highlighter-rouge">bar</code> definiscono l’identificatore <code class="highlighter-rouge">baz</code> ma <code class="highlighter-rouge">foo</code> viene registrato per primo e quindi il compilatore inserirebbe <code class="highlighter-rouge">use foo::baz;</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">mod</span> <span class="n">foo</span><span class="p">;</span>
<span class="k">mod</span> <span class="n">bar</span><span class="p">;</span>

<span class="c">// use foo::baz  // ciò che sarebbe inserito.</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">baz</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Sapendo questa dinamica, probabilmente risparmieresti qualche carattere ma aumenteresti anche la possibilità di generare degli errori imprevisti quando in realtà al posto di <code class="highlighter-rouge">baz()</code> intendevi <code class="highlighter-rouge">bar::baz()</code>, diminuendo anche la leggibilità del codice,
avendo reso la chiamata alla funzione dipendente dall’ordine di dichiarazione. Questi sono compromessi che Rust non ha intenzione di prendere.</p>

<p>Ad ogni modo, in futuro, un ambiente di sviluppo integrato potrebbe assistere nella gestione delle dichiarazioni, fornendo il massimo di entrambi i mondi: assistenza automatica nelle dichiarazioni ma chiarezza sulle origini dei nomi importati.</p>

<!--
### How do I package and archive crates from [https://crates.io](https://crates.io)?

TODO: Write this answer.
-->

<h3><a href="#how-do-i-do-dynamic-rust-library-loading" name="how-do-i-do-dynamic-rust-library-loading">
Come carico dinamicamente librerie in Rust?
</a></h3>

<p>Puoi importare librerie dinamiche in Rust con <a href="https://crates.io/crates/libloading">libloading</a>, che fornisce un sistema multipiattaforma per il link dinamico.</p>

<h3><a href="#why-doesnt-crates-io-have-namespaces" name="why-doesnt-crates-io-have-namespaces">
Perchè crates.io non ha uno spazio dei nomi?
</a></h3>

<p>Citando la <a href="https://internals.rust-lang.org/t/crates-io-package-policies/1041">spiegazione ufficiale</a> sul design di <a href="https://crates.io">https://crates.io</a>:</p>

<blockquote>
  <p>Nel primo mese di crates.io, un buon numero di persone hanno richiesto la possibilità di introdurre <a href="https://github.com/rust-lang/crates.io/issues/58">pacchetti con spazi dei nomi</a>.<br /><br /></p>

  <p>Mentre questi permettono a autori multipli di utilizzare un singolo nome generico, aggiungono complessità su come i pacchetti vengono indicati nel codice Rust e nella comunicazione su di essi. A una prima occhiata questo permetterebbe a più persone di associarsi al nome <code class="highlighter-rouge">http</code>, ma questo implicherebbe che per riferirsi a due pacchetti di autori diversi si debbe parlare ad esempio di <code class="highlighter-rouge">http di wycats</code> o di <code class="highlighter-rouge">http di reem</code>, offrendo pochi vantaggi rispetto a nomi come <code class="highlighter-rouge">wycats-http</code> o <code class="highlighter-rouge">reem-http</code>.<br /><br /></p>

  <p>Inoltre, osservando questa scelta abbiamo scoperto che le persone tendono a utilizzare nomi più creativi (come <code class="highlighter-rouge">nokogiri</code> invece che “libxml2 di tendelove”). Questi nomi creativi tendono a essere brevi e memorabili, in parte anche grazie della mancanza di dipendenze da altri. Rendono anche più semplice parlare in modo conciso e non ambiguo di pacchetti, creando nuovi nomi altisonanti. Esistono diversi ecosistemi da oltre 10,000 pacchetti come NPM e RubyGems le cui comunità prosperano anche sotto un singolo spazio dei nomi.<br /><br /></p>

  <p>In breve, non pensiamo che l’ecosistema Cargo avrebbe giovamento se Piston scegliesse un nome come <code class="highlighter-rouge">bvssvni/game-engine</code> (permettendo ad altri di scegliere <code class="highlighter-rouge">wycats/game-engine</code>) invece che semplicemente <code class="highlighter-rouge">piston</code>.<br /><br /></p>

  <p>Proprio perché gli spazi dei nomi sono più complessi in diversi ambiti ed essendo la loro aggiunta possibile se necessario, per ora abbiamo intenzione di preservare un singolo spazio dei nomi condiviso.</p>
</blockquote>

<h2 id="libraries">Librerie</h2>

<h3><a href="#how-can-i-make-an-http-request" name="how-can-i-make-an-http-request">
Come faccio a fare una richiesta HTTP?
</a></h3>

<p>La libreria standard non contiene un’implementazione di HTTP quindi dovrai utilizzare un pacchetto esterno.
<a href="https://github.com/hyperium/hyper">Hyper</a> è la più popolare ma ce ne sono <a href="https://crates.io/keywords/http">tante altre</a>.</p>

<h3><a href="#how-can-i-write-a-gui-application" name="how-can-i-write-a-gui-application">
Come faccio a scrivere un applicativo con interfaccia grafica in Rust?
</a></h3>

<p>Ci sono molti modi per fare applicazioni con interfaccia grafica in Rust.
Guarda questa lista di <a href="https://github.com/kud1ing/awesome-rust#gui">librerie per realizzare interfacce grafiche</a>.</p>

<h3><a href="#how-can-i-parse-json-xml" name="how-can-i-parse-json-xml">
Come faccio a deserializzare JSON/XML?
</a></h3>

<p><a href="https://github.com/serde-rs/serde">Serde</a> è la libreria consigliata per serializzare e deserializzare di dati in Rust da e verso una moltitudine di formati.</p>

<h3><a href="#is-there-a-standard-2d-vector-crate" name="is-there-a-standard-2d-vector-crate">
Esiste una libreria standard per la geometria e vettoriali 2D+?
</a></h3>

<p>Non ancora! Puoi farne una tu?</p>

<h3><a href="#how-do-i-write-an-opengl-app" name="how-do-i-write-an-opengl-app">
Come faccio a creare un applicativo OpenGL in Rust?
</a></h3>

<p><a href="https://github.com/tomaka/glium">Glium</a> è la principale libreria per utilizzare OpenGL in Rust. <a href="https://github.com/bjz/glfw-rs">GLFW</a> è un’altra opzione valida.</p>

<h3><a href="#can-i-write-a-video-game-in-rust" name="can-i-write-a-video-game-in-rust">
Posso fare un videogioco in Rust?
</a></h3>

<p>Certo! La principale libreria per programmare giochi in Rust è <a href="http://www.piston.rs/">Piston</a> ci  sono sia un <a href="https://www.reddit.com/r/rust_gamedev/">subreddit per la creazione di videogiochi in Rust</a> e un canale IRC (<code class="highlighter-rouge">#rust-gamedev</code> su <a href="https://wiki.mozilla.org/IRC">Mozilla IRC</a>).</p>

<h2 id="design-patterns">Paradigmi di programmazione</h2>

<h3><a href="#is-rust-object-oriented" name="is-rust-object-oriented">
Rust è orientato agli oggetti?
</a></h3>

<p>Rust è multi paradigma. Molte cose possibili in linguaggi orientati agli oggetti sono possibili in Rust ma non proprio tutto e non sempre utilizzando un livello di astrazione uguale a quello a cui si è abituati.</p>

<h3><a href="#how-do-i-map-object-oriented-concepts-to-rust" name="how-do-i-map-object-oriented-concepts-to-rust">
Come converto concetti della programmazione orientata agli oggetti in Rust?
</a></h3>

<p>Dipende. <em>Esistono</em> modi per convertire concetti orientati agli oggetti come <a href="https://www.reddit.com/r/rust/comments/2sryuw/ideaquestion_about_multiple_inheritence/">ereditarietà multiple</a> a Rust ma non essendo Rust orientato agli oggetti il risultato della conversione potrenne apparire sostanzialmente diverso dalla sua rappresentazione in un linguaggio orientato agli oggetti.</p>

<h3><a href="#how-do-i-configure-a-struct-with-optional-parameters" name="how-do-i-configure-a-struct-with-optional-parameters">
Come gestisco la configurazione di una `struct` con parametri opzionali?
</a></h3>

<p>Il modo più semplice è utilizzare il tipo <a href="https://doc.rust-lang.org/stable/std/option/enum.Option.html"><code class="highlighter-rouge">Option</code></a> in qualsiasi funzione venga utilizzata per costruire istanze della struttura (generalmente <code class="highlighter-rouge">new()</code>).
Un altro modo è utilizzare il <a href="https://doc.rust-lang.org/stable/book/first-edition/method-syntax.html#builder-pattern">metodo del costruttore</a>, dove alcune funzioni devono essere chiamate dopo la costruzione del tipo.</p>

<h3><a href="#how-do-i-do-global-variables" name="how-do-i-do-global-variables">
Come faccio le variabili globali in Rust?
</a></h3>

<p>Le globali in Rust possono essere fatte utilizzando la dichiarazione <code class="highlighter-rouge">const</code> per le globali computate al momento della compilazione, mentre <code class="highlighter-rouge">static</code> è utilizzabile per globali mutabili.
Nota che la modifica di una variabile <code class="highlighter-rouge">static mut</code> richiede <code class="highlighter-rouge">unsafe</code>, visto che permette problemi di concorrenza, una cosa impossibile nel Rust sicuro.
Una differenza importante tra <code class="highlighter-rouge">const</code> e <code class="highlighter-rouge">static</code> è che si possono prendere riferimenti a valori <code class="highlighter-rouge">static</code> ma non a valori <code class="highlighter-rouge">const</code> se privi di posizione in memoria specificata.
Per ulteriori informazioni su <code class="highlighter-rouge">const</code> e <code class="highlighter-rouge">static</code>, leggi <a href="https://doc.rust-lang.org/book/const-and-static.html">il libro di Rust</a>.</p>

<h3><a href="#how-can-i-set-compile-time-constants-that-are-defined-procedurally" name="how-can-i-set-compile-time-constants-that-are-defined-procedurally">
Come faccio a impostare delle costanti al momento della compilazione proceduralmente?
</a></h3>

<p>Rust attualmente possiede un supporto limitato per le costanti al momento della compilazione.
Puoi definire dei primitivi con le dichiarazioni <code class="highlighter-rouge">const</code> (simili a <code class="highlighter-rouge">static</code> ma immutabili e senza una specifica locazione in memoria) funzioni <code class="highlighter-rouge">const</code> e metodi correlati.</p>

<p>Per definire costanti procedurali che non possono essere definite tramite questi meccanismi usa il pacchetto <a href="https://github.com/rust-lang-nursery/lazy-static.rs"><code class="highlighter-rouge">lazy-static</code></a>, che emula l’assegnazione al momento della compilazione assegnando il valore al primo utilizzo.</p>

<h3><a href="#can-i-run-code-before-main" name="can-i-run-code-before-main">
Posso eseguire del codice di inizializzazione prima di main?
</a></h3>

<p>Rust non consente l’esistenza di qualcosa prima di <code class="highlighter-rouge">main</code>.
La cosa più vicina può essere fatta tramite il pacchetto <a href="https://github.com/Kimundi/lazy-static.rs"><code class="highlighter-rouge">lazy-static</code></a>, simulante una situazione “pre-main” in cui le variabili statiche vengono inizializzate al loro primo utilizzo.</p>

<!--

This answer needs significant work. Let's revise after the initial posting. --aturon

<h3><a href="#why-doesnt-rust-have-inheritance" name="why-doesnt-rust-have-inheritance">
Why doesn't Rust have inheritance?
</a></h3>

There are two meanings for the word "inheritance": _subtyping_, and _interface sharing_. Both purposes are already handled by traits.

For the first, subtyping exists for polymorphism, which traits already provide.

For the second, interface sharing is handled via trait methods, which define a collection of related functions that must be implemented for any implementation of the trait.

Rust has consistently worked to avoid having features with overlapping purposes, preferring to keep features orthogonal. For this reason, and given that the two major purposes are already handled by traits, Rust has opted not to include inheritance.

-->

<h3><a href="#does-rust-allow-non-constant-expression-values-for-globals" name="does-rust-allow-non-constant-expression-values-for-globals">
Rust permette di assegnare alle globali espressioni non costanti?
</a></h3>

<p>No. Le globali non possono non avere un costruttore costante e non possiedono un destrutture. I costruttori statici sono sconvenienti perché assicurare un ordine di inizializzazione statico è complesso. Le situazioni “pre-main” sono spesso considerate sconvenienti e Rust non le consente.</p>

<p>Leggi anche il <a href="http://yosefk.com/c++fqa/ctors.html#fqa-10.12">domande frequenti del C++</a> che fa menzione del “problema dell’ordine di inizializzazione per le static” e il <a href="https://ericlippert.com/2013/02/06/static-constructors-part-one/">blog di Eric Lippert</a> per le problematiche in C#, che anche esso possiede queste funzioni.</p>

<p>Puoi emulare globali il cui valore non è costante con il pacchetto <a href="https://crates.io/crates/lazy_static/">lazy-static</a>.</p>

<h2 id="other-languages">Altri linguaggi</h2>

<h3><a href="#how-can-i-use-static-fields" name="how-can-i-use-static-fields">
Come posso implementare in Rust quello che in C si può ottenere con <code>struct X { static int X; };</code> ?
</a></h3>

<p>Rust non possiede campi <code class="highlighter-rouge">static</code> come nel codice sopra. Al loro posto puoi dichiarare una varibile <code class="highlighter-rouge">static</code> a un determinato modulo, che viene preservata privata all’interno dello stesso.</p>

<h3><a href="#how-can-i-convert-a-c-style-enum-to-an-integer" name="how-can-i-convert-a-c-style-enum-to-an-integer">
Come converto una enum simil-C a un intero e vice versa?
</a></h3>

<p>Convertire una enum simil-C a un intero è possibile con l’espressione <code class="highlighter-rouge">as</code> come in <code class="highlighter-rouge">e as i64</code> (dove <code class="highlighter-rouge">e</code> è una enum).</p>

<p>La conversione in altre direzioni può essere svolta tramite <code class="highlighter-rouge">match</code>, che associa differenti valori numerici a differenti potenziali valori per la enum.</p>

<h3><a href="#why-do-rust-programs-use-more-memory-than-c" name="why-do-rust-programs-use-more-memory-than-c">
Perché i programmi in Rust sono più grandi su disco di programmi C?
</a></h3>

<p>Ci sono diversi fattori che contribuiscono alla tendenza di Rust di avere in generale file binari più grandi di programmi funzionalmente equivalenti in C.
In generale Rust si focalizza su ottimizzare le prestazioni di programmi reali, non le dimensioni di piccoli programmi.</p>

<p><strong>Monomorfizzazione</strong></p>

<p>Rust monomorfizza i generici, ovvero che viene generata una nuova versione di una funzione generica o tipo per ciascuna dichiarazione effettuata con tipi distinti. Questo assomiglia ai template in C++. Ad esempio, nel programma seguente:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="n">foo</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// ... qualcosa</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">foo</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>       <span class="c">// i32</span>
    <span class="nf">foo</span><span class="p">(</span><span class="s">"ciao"</span><span class="p">);</span>  <span class="c">// &amp;str</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Nel file eseguibile finale vi saranno due versioni diverse di <code class="highlighter-rouge">foo</code>, una specifica al tipo in ingresso <code class="highlighter-rouge">i32</code> e l’altra specifica al tipo in ingresso <code class="highlighter-rouge">&amp;str</code>.
Questo permette un efficiente dispacciamento statico della funzione generica ma aumentando le dimensioni dell’eseguibile finale.</p>

<p><strong>Simboli di debug</strong></p>

<p>I programmi Rust sono compilati con i simboli di debug inclusi, anche se in modalità rilascio. Questi sono utilizzabili per fornire informazioni in caso di crash e possono essere rimossi con <code class="highlighter-rouge">strip</code>, o un qualsiasi altro strumento per la rimozione di simboli di debug.
Risulta utile sapere anche che compilare in modalità rilascio con Cargo equivale a impostare il livello di ottimizzazione 3 con rustc.
Un livello alternativo di ottimizzazione (chiamato <code class="highlighter-rouge">s</code> o <code class="highlighter-rouge">z</code>) <a href="https://github.com/rust-lang/rust/pull/32386">aggiunto recentemente</a> indica al compilatore di focalizzarsi invece che sulle prestazioni, sulle dimensioni dell’eseguibile finale.</p>

<p><strong>Jemalloc</strong></p>

<p>Rust utilizza jemalloc come il suo allocatore predefinito, questo aumenta le dimensioni dei binari compilati.
Jemalloc è stato scelto perché è un allocatore consistente e di qualità con caratteristiche prestazionali preferibili rispetto agli allocatori forniti da molti sistemi.
Al momento si stanno facendo esperimenti su come <a href="https://github.com/rust-lang/rust/issues/32838">rendere più facile l’utilizzo di allocatori personalizzati</a> ma la funzionalità non è stata ancora ultimata.</p>

<p><strong>Ottimizzazione del linker</strong></p>

<p>Rust di base non effettua ottimizzazioni al momento del linking ma gli più essere detto di farlo.
Questo incrementa la quantità di ottimizzazioni effettuabili e può avere un effetto sulle dimensioni dei binari generati, questo effetto può essere amplificato se in combinazione con l’opzione di ottimizzazione per dimensioni sopracitata.</p>

<p><strong>Libreria standard</strong></p>

<p>La libreria standard di Rust include libbacktrace e libunwind, che potrebbero essere non volute in alcuni programmi.
Utilizzare <code class="highlighter-rouge">#![no_std]</code> può quindi fornire dei binari più piccoli ma cambia in modo sostanziale il modo in cui il codice deve essere scritto.
Nota che utilizzare Rust senza la libreria standard è spesso funzionalmente vicino al codice C equivalente.</p>

<p>Per esempio, il programma seguente in C legge un nome e dice “ciao” alla persona con quel nome:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Come ti chiami?</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Ciao %s!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Per riscrivere questo programma in Rust scriveresti una cosa del genere:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Come ti chiami?"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nn">io</span><span class="p">::</span><span class="nf">stdin</span><span class="p">()</span><span class="nf">.read_line</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Ciao {}!"</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Questo programma, quando compilato e confrontato con il programma C avrà una dimensione maggiore e utilizzerà più memoria ma non è esattamente equivalente al codice C che lo precede.
Il reale equivalente in realtà assomiglia di più a questo:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">lang_items</span><span class="p">)]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">libc</span><span class="p">)]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">no_std</span><span class="p">)]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">start</span><span class="p">)]</span>
<span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="n">no_std</span><span class="p">]</span>

<span class="k">extern</span> <span class="n">crate</span> <span class="n">libc</span><span class="p">;</span>

<span class="k">extern</span> <span class="s">"C"</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">printf</span><span class="p">(</span><span class="n">fmt</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="err">...</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">scanf</span><span class="p">(</span><span class="n">fmt</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">,</span> <span class="err">...</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i32</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#[start]</span>
<span class="k">fn</span> <span class="nf">start</span><span class="p">(</span><span class="n">_argc</span><span class="p">:</span> <span class="n">isize</span><span class="p">,</span> <span class="n">_argv</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="o">*</span><span class="k">const</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">isize</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nf">printf</span><span class="p">(</span><span class="n">b</span><span class="s">"Come ti chiami?</span><span class="se">\n</span><span class="err">\</span><span class="s">0"</span><span class="nf">.as_ptr</span><span class="p">());</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">input</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="mi">100</span><span class="p">];</span>
        <span class="nf">scanf</span><span class="p">(</span><span class="n">b</span><span class="s">"</span><span class="si">%s</span><span class="err">\</span><span class="s">0"</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">input</span><span class="p">);</span>
        <span class="nf">printf</span><span class="p">(</span><span class="n">b</span><span class="s">"Ciao </span><span class="si">%s</span><span class="s">!</span><span class="se">\n</span><span class="err">\</span><span class="s">0"</span><span class="nf">.as_ptr</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>
        <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[lang=</span><span class="s">"eh_personality"</span><span class="cp">]</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">eh_personality</span><span class="p">()</span> <span class="p">{}</span>
<span class="cp">#[lang=</span><span class="s">"panic_fmt"</span><span class="cp">]</span> <span class="k">fn</span> <span class="nf">panic_fmt</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">!</span> <span class="p">{</span> <span class="k">loop</span> <span class="p">{}</span> <span class="p">}</span>
<span class="cp">#[lang=</span><span class="s">"stack_exhausted"</span><span class="cp">]</span> <span class="k">extern</span> <span class="k">fn</span> <span class="nf">stack_exhausted</span><span class="p">()</span> <span class="p">{}</span>
</code></pre>
</div>

<p>Che dovrebbe certamente eguagliare il C nell’utilizzo della memoria, incrementando peró la complessità e rimuovendo le garanzie fornite dal codice Rust (evitate utilizzando <code class="highlighter-rouge">unsafe</code>).</p>

<h3><a href="#why-no-stable-abi" name="why-no-stable-abi">
Perchè Rust non ha una ABI stabile come il C e perché devo annotare le cose con extern?
</a></h3>

<p>Dedicarsi a una ABI è una decisione importante che può limitare i cambiamenti vantaggiosi futuri. Dato che Rust ha raggiunto la versione 1.0 a Maggio 2015 è troppo presto per impegnarsi a costruire una ABI stabile. Ció peró non implica che non possa succedere nel futuro.
(Nonostante questo il C++ è riuscito a vivere per molti anni senza specificare una ABI stabile.)</p>

<p>Il lemma <code class="highlighter-rouge">extern</code> permette di usare con Rust specifiche ABI, come quella ben definita del C, per interoperare con altri linguaggi.</p>

<h3><a href="#can-rust-code-call-c-code" name="can-rust-code-call-c-code">
Può il codice Rust chiamare il codice C?
</a></h3>

<p>Si. Chiamare il C da Rust è progettato per avere la stessa efficienza delle chiamate di codice C dal C++.</p>

<h3><a href="#can-c-code-call-rust-code" name="can-c-code-call-rust-code">
Può il codice C chiamare il codice Rust?
</a></h3>

<p>Si. Il codice Rust deve essere sposto mediante una dichiarazione <code class="highlighter-rouge">extern</code>, che lo rende compatibile con la ABI del C.
Tale funzione può essere passata al codice C come puntatore a una funzione o, se con l’attributo <code class="highlighter-rouge">#[no_mangle]</code> chiamata direttamente dal C.</p>

<h3><a href="#why-rust-vs-cxx" name="why-rust-vs-cxx">
Scrivo già del C++ perfetto. Cosa mi fornisce di più Rust?
</a></h3>

<p>Il C++ moderno include molte funzioni che rendono la scrittura di codice sicuro e corretto meno prono ad errori ma non è perfetto e rimane comunque facile introdurre vulnerabilità.
Gli sviluppatori del C++ stanno cercando di porre rimedio a queste problematiche ma il C++ è limitato da una lunga storia che impedisce di attuare molte idee che si vorrebbero sperimentare.</p>

<p>Rust è stato disegnato sin dal primo giorno per essere un linguaggio di programmazione per sistemi sicuro, questo significa che non è limitato da scelte pregresse che potrebbero impedire di raggiungere il corretto livello di sicurezza come il C++.
In C++, la sicurezza si ottiene mediante una rigorosa disciplina personale ed è semplice commettere errori mentre in Rust, la sicurezza è predefinita.
Rust permette quindi di lavorare in un gruppo di persone meno perfette di te, senza dover spendere il tuo tempo per controllare il codice altrui per controllare potenziali falle di sicurezza nel codice altrui.</p>

<h3><a href="#how-to-get-cxx-style-template-specialization" name="how-to-get-cxx-style-template-specialization">
Come creo l'equivalente della specializzazione dei template del C++ in Rust?
</a></h3>

<p>Rust attualmente non ha un equivalente esatto alla specializzazione dei template ma <a href="https://github.com/rust-lang/rfcs/pull/1210">ci si sta lavorando su</a> e verrà probabilmente aggiunta a presto.
Ad ogni modo, effetti simili si possono ottenere con i <a href="https://doc.rust-lang.org/stable/book/associated-types.html">tipi associati</a>.</p>

<h3><a href="#how-does-ownership-relate-to-cxx-move-semantics" name="how-does-ownership-relate-to-cxx-move-semantics">
Come si compara il sistema dei possessi in Rust con le semantiche del movimento in C++?
</a></h3>

<p>I concetti base sono simili ma i due sistemi differiscono nella pratica.
In entrambi i sistemi “muovere” un valore è un modo per trasferire il possesso
delle risorse sottostanti. Ad esempio, muovere una stringa trasferisce il suo buffer
al posto di copiarla.</p>

<p>In Rust il trasferimento di possesso è il comportamento standard.
Ad esempio, se scrivo una funzione che accetta una <code class="highlighter-rouge">String</code> come parametro,
questa funzione prenderà possesso del valore della <code class="highlighter-rouge">String</code> fornita dal chiamante:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">elabora</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">fn</span> <span class="nf">chiamante</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Ciao mondo!"</span><span class="p">);</span>
    <span class="nf">elabora</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c">// Trasferisce la proprietà di `s` a `elabora`</span>
    <span class="nf">elabora</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c">// Errore! il possesso è già stato trasferito.</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Come puoi vedere nel frammento di codice sopra, nella funzione <code class="highlighter-rouge">chiamante</code>,
la prima chiamata a <code class="highlighter-rouge">elabora</code> trasferisce il possesso della variabile <code class="highlighter-rouge">s</code>.
Il compilatore tiene traccia del possesso, quindi una seconda chiamata a
<code class="highlighter-rouge">elabora</code> genere un errore perché non è consentito trasferire il possesso
dello stesso valore due volte.
Rust previene anche il movimento di un valore se vi è ancora un
riferimente ad esso.</p>

<p>Il C++ ha un approccio distinto, il comportamento predefinito è infatti
di copiare un valore (nello specifico invocandone il costruttore della copia).
Ad ogni modo i chiamati possono dichiarare i loro parametri utilizzando
un “riferimento rvalore” come <code class="highlighter-rouge">string&amp;&amp;</code>, per indicare che prenderanno
possesso di parte delle risorse possedute dal paramentro(in questo caso
il buffer interno della stringa).
Il chiamante deve quindi passare un’espressione temporanea o effettuare
un movimento esplicito utilizzando <code class="highlighter-rouge">std::move</code>.
Un abbozzo della funzione <code class="highlighter-rouge">elabora</code> sopra sarebbe quindi:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void elabora(string&amp;&amp; s) { }

void chiamante() {
    string s("Ciao mondo!");
    elabora(std::move(s));
    elabora(std::move(s));
}
</code></pre>
</div>

<p>I compilatori C++ non sono tenuti a tenere traccia dei movimenti.
Ad esempio, il codice sopra viene compilato senza alcun avviso o errore
utilizzando l’ultima versione di Clang.
Inoltre in C++ il possesso della stringa <code class="highlighter-rouge">s</code> stessa
(se non del suo buffer interno) rimane in <code class="highlighter-rouge">chiamante</code>, e quindi il
destruttore di <code class="highlighter-rouge">s</code> verrà eseguito quando <code class="highlighter-rouge">chiamante</code> ritorna, anche se
è stato spostato (in Rust, al contrario, i valori spostati sono rimossi
dai nuovi proprietari).</p>

<h3><a href="#how-to-interoperate-with-cxx" name="how-to-interoperate-with-cxx">
Come posso interoperare il C++ da Rust, o il Rust da C++?
</a></h3>

<p>Il Rust è il C++ possono interoperare tramite il C. Sia il Rust che il C++ forniscono una <a href="https://doc.rust-lang.org/book/ffi.html">foreign function interface</a> per il C, che può essere utilizzata per comunicare tra di loro.
Se scrivere dei collegamenti in C è troppo complicato, puoi sempre utilizzare <a href="https://github.com/servo/rust-bindgen">rust-bindgen</a> per generare automaticamente dei collegamenti C++ funzionanti.</p>

<h3><a href="#does-rust-have-cxx-style-constructors" name="does-rust-have-cxx-style-constructors">
Rust possiede dei costruttori in stile C++?
</a></h3>

<p>No. Al loro posto si utilizzano delle funzioni, il cui nome usuale è <code class="highlighter-rouge">new()</code>, ad ogni modo questa è semplicemente una convenzione e non una regola del linguaggio.
La funzione <code class="highlighter-rouge">new()</code> è semplicemente un’altra funzione. Un esempio di ciò è questo:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">f64</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Foo</span> <span class="p">{</span>
        <span class="n">Foo</span> <span class="p">{</span>
            <span class="n">a</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">b</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="n">c</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3><a href="#does-rust-have-copy-constructors" name="does-rust-have-copy-constructors">
Rust possiede dei costruttori copia?
</a></h3>

<p>Non esattamente. I tipi che implementano <code class="highlighter-rouge">Copy</code> faranno una copia simil-C senza alcun lavoro aggiuntivo.
Non è possibile peró implementare tipi <code class="highlighter-rouge">Copy</code> che richiedono un comportamento personalizzato alla copia.
Al loro posto in Rust i costruttori copia sono creati implementando il tratto e successivamente chiamando il metodo <code class="highlighter-rouge">clone</code>.
Permettere di definire manualmente l’operatore copia permette di ridurre la complessità, facilitando per lo sviluppatore l’identificazione di operazioni potenzialmente costose.</p>

<h3><a href="#does-rust-have-move-constructors" name="does-rust-have-move-constructors">
Rust possiede dei costruttori di movimento?
</a></h3>

<p>No. I valori di tutti i tipi sono mossi tramite <code class="highlighter-rouge">memcpy</code>.
Questo permette di scrivere del codice <code class="highlighter-rouge">unsafe</code> generico molto più semplice, dato che l’assegnazione, il passaggio e il ritorno di valori sono privi di effetti collaterali.</p>

<h3><a href="#compare-go-and-rust" name="compare-go-and-rust">
In cosa si assomigliano Go e Rust, in cosa sono invece diversi?
</a></h3>

<p>Rust e Go hanno degli obiettivi molto differenti. Le differenze seguenti non sono le uniche (sarebbero troppe per elencarle) ma eccone alcune tra le più importanti:</p>

<ul>
  <li>Rust è di più basso livello di Go. Ad esempio, Rust non richiede un garbage collector, mentre Go sí. In generale Rust permette un livello di controllo comparabile con il C o il C++.</li>
  <li>Rust si focalizza sul garantire sicurezza ed efficienza mantenendo astrazioni di alto livello mentre Go vuole essere un linguaggio compatto e semplice che compila velocemente e può funzionare con molti strumenti.</li>
  <li>Rust supporta la programmazione generica, Go no.</li>
  <li>Rust ha forti influenze dal mondo della programmazione funzionale, includendo il sistema dei tipi derivato dalle typeclasses di Haskell. Go ha un sistema dei tipi più semplici, utilizzanti interfacce compatibili con la programmazione generica.</li>
</ul>

<h3><a href="#how-do-rust-traits-compare-to-haskell-typeclasses" name="how-do-rust-traits-compare-to-haskell-typeclasses">
Come si comparano i tratti di Rust con le typeclasses di Haskell?
</a></h3>

<p>I tratti in Rust somigliano alle typeclasses di Haskell ma attualmente non sono così potenti, dato che Rust non può esprimere i tipi di più altro livello. I tipi associati di Rust sono gli equivalenti delle famiglie di tipi di Haskell.</p>

<p>Alcune differenze specifiche tra le typeclasses di Haskell e i tratti di Rust includono:</p>

<ul>
  <li>I tratti in Rusta hanno un primo parametro implicito chiamato <code class="highlighter-rouge">Self</code>. <code class="highlighter-rouge">trait Bar</code> in Rust corrisponde a <code class="highlighter-rouge">class Bar self</code> in Haskell e <code class="highlighter-rouge">trait Bar&lt;Foo&gt;</code> in Rust corrisponde a <code class="highlighter-rouge">class Bar foo self</code> in Haskell.</li>
  <li>I “Supertratti” o “limitatori di superclass” in Rust sono scritti <code class="highlighter-rouge">trait Sub: Super</code>, mentre in Haskell <code class="highlighter-rouge">class Super self =&gt; Sub self</code>.</li>
  <li>Rust vieta istanze orfanes, indicando regole di coerenza differenti tra Rust e Haskell.</li>
  <li>La risoluzione dell <code class="highlighter-rouge">impl</code> di Rust considera le clausole <code class="highlighter-rouge">where</code> e i relativi tratti per decidere se due <code class="highlighter-rouge">impl</code> si sovrappongono, o per scegliere tra diverse <code class="highlighter-rouge">impl</code> possibili. Haskell considera ciò solo nelle dichiarazioni <code class="highlighter-rouge">instance</code>, ignorando ogni limitazione posta altrove.</li>
  <li>Un sottoinsieme dei tratti di Rust (Quelli <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">“object safe”</a>) può essere usato per il dispacciamento dinamico mediante tratti. La stessa funzionalità è disponibile in Haskell attraverso il metodo di GHC <code class="highlighter-rouge">ExistentialQuantification</code>.</li>
</ul>

<h2 id="documentation">Documentazione</h2>

<h3><a href="#why-are-so-many-rust-answers-on-stackoverflow-wrong" name="why-are-so-many-rust-answers-on-stackoverflow-wrong">
Perchè su Stack Overflow molte delle risposte su Rust sono sbagliate?
</a></h3>

<p>Il linguaggio Rust è pubblico da diversi anni e ha raggiunto la versione 1.0 a Maggio del 2015.
Nei periodi precedenti il linguaggio ha ricevuto delle modifiche sostanziali e molte risposte fanno riferimento a versioni vecchie del linguaggio.</p>

<p>Nel tempo sempre più risposte saranno disponibili per la versione corrente, migliorando la problematica alterando il rapporto tra le risposte corrette e quelle sbagliate.</p>

<h3><a href="#where-do-i-report-issues-in-the-rust-documentation" name="where-do-i-report-issues-in-the-rust-documentation">
Dove segnalo problemi alla documentazione di Rust?
</a></h3>

<p>Puoi segnalare problemi con la documentazione sul <a href="https://github.com/rust-lang/rust/issues">pannello delle problematiche</a> di Rust.
Assicurati peró di leggere <a href="https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#writing-documentation">linee guida alla contribuzione</a> prima.</p>

<h3><a href="#how-do-i-view-rustdoc-documentation-for-a-library-my-project-depends-on" name="how-do-i-view-rustdoc-documentation-for-a-library-my-project-depends-on">
Come posso vedere la documentazione di rustdoc di una dipendenza del mio progetto?
</a></h3>

<p>Quando utilizzi <code class="highlighter-rouge">cargo doc</code> per generare la documentazione per il tuo progetto, il comando genera anche la documentazione per le dipendenze attive.
Le puoi trovare nella cartella <code class="highlighter-rouge">target/doc</code> del progetto.
Usa <code class="highlighter-rouge">cargo doc --open</code> per aprire i documenti dopo averli generati o semplicemente apri da solo <code class="highlighter-rouge">target/doc/index.html</code>.</p>



    <footer>
      <p>Il nostro sito in altre lingue:
        <a href="/de-DE/">Deutsch</a>,
<a href="/en-US/">English</a>,
<a href="/es-ES/">Español</a>,
<a href="/fr-FR/">Français</a>,
<a href="/id-ID/">Bahasa Indonesia</a>,
<a href="/it-IT/">Italiano</a>,
<a href="/ja-JP/">日本語</a>,
<a href="/ko-KR/">한국어</a>,
<a href="/pl-PL/">Polski</a>,
<a href="/pt-BR/">Português</a>,
<a href="/ru-RU/">Русский</a>,
<a href="/sv-SE/">Svenska</a>,
<a href="/vi-VN/">Tiếng việt</a>,
<a href="/zh-CN/">简体中文</a>

      </p>
    </footer>
  </body>
</html>
